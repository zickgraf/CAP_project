<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (FreydCategoriesForCAP) - Chapter 14: Examples on graded rows and columns</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap14"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap13.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap15.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap14_mj.html">[MathJax on]</a></p>
<p><a id="X87E337DD810FE4CA" name="X87E337DD810FE4CA"></a></p>
<div class="ChapSects"><a href="chap14.html#X87E337DD810FE4CA">14 <span class="Heading">Examples on graded rows and columns</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X7B1E187B81C3D9CE">14.1 <span class="Heading">Freyd category of graded rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X7EFC6E1778B1A18D">14.2 <span class="Heading">Freyd category of graded columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X783430D884689E27">14.3 <span class="Heading">Constructors of objects and reduction of degree lists</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X7A9CA0C983ECE36B">14.4 <span class="Heading">Constructors of morphisms</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X827E565A7F15C748">14.5 <span class="Heading">The GAP categories</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X7A34A184800E1DD6">14.6 <span class="Heading">A few categorical constructions for graded rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X7E3CC2FB7DD5B4F8">14.7 <span class="Heading">A few categorical constructions for graded columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X7D4C656384F41D31">14.8 <span class="Heading">Additional examples on monoidal structure for graded rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X83218D197FAD5A73">14.9 <span class="Heading">Additional examples on monoidal structure for graded columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap14.html#X78BBD81679376CA5">14.10 <span class="Heading">Examples to test Tools methods in graded rows/cols</span></a>
</span>
</div>
</div>

<h3>14 <span class="Heading">Examples on graded rows and columns</span></h3>

<p><a id="X7B1E187B81C3D9CE" name="X7B1E187B81C3D9CE"></a></p>

<h4>14.1 <span class="Heading">Freyd category of graded rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationalsInSingular();</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := GradedRing( Q * "x_1, x_2, x_3, x_4" );</span>
Q[x_1,x_2,x_3,x_4]
(weights: yet unset)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetWeightsOfIndeterminates( S, [[1,0],[1,0],[0,1],[0,1]] );</span>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CategoryOfGradedRows( S );</span>
Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := GradedRow( [ [[1,1],1] ], S );</span>
&lt;A graded row of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := GradedRow( [ [[1,1],2] ], S );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := GradedRowOrColumnMorphism( obj2, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       HomalgMatrix( [ [ 1, 1 ], [ 1, 1 ] ], 2, 2, S ), obj2 );</span>
&lt;A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">freyd := FreydCategory( cat );</span>
Category of f.p. graded left modules over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelianCategory( freyd );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_gamma := FreydCategoryObject( gamma );</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreydCategoryMorphism( obj_gamma, gamma, obj_gamma );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">witness := MorphismWitness( f );</span>
&lt;A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( witness );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

Matrix:
2,0,
2,0
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FreydCategoryMorphism( obj_gamma, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   ZeroMorphism( obj2, obj2 ), obj_gamma );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( f, g );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := PreCompose( f, f );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( c );</span>
A morphism in Category of f.p. graded left modules over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) )

--------------------------------

Source:
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

Matrix:
1,1,
1,1
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

--------------------------------

Morphism datum:
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

Matrix:
2,2,
2,2 
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

--------------------------------

Range:
A morphism in Category of graded row over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

Matrix:
1,1,
1,1
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

--------------------------------
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := g + g;</span>
&lt;A morphism in Category of f.p. graded left modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := GradedRowOrColumnMorphism( obj1, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                 HomalgMatrix( [ [ 2 ] ], 1, 1, S ), obj1 );</span>
&lt;A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( a );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]

Matrix:
2
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z2 := FreydCategoryObject( a );</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Z2 );</span>
An object in Freyd( Category of graded rows over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) )

Relation morphism:
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]

Matrix:
2
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( Z2 );</span>
&lt;An identity morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id + id;</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := DirectSumFunctorial( [ z, z, z ] );</span>
&lt;A morphism in Category of f.p. graded left modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr2 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr3 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 3 );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">uni := UniversalMorphismIntoDirectSum( [ pr3, pr2 ] );</span>
&lt;A morphism in Category of f.p. graded left modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 1 );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">uni2 := UniversalMorphismFromDirectSum( [ inj2, inj1 ] );</span>
&lt;A morphism in Category of f.p. graded left modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZFree := AsFreydCategoryObject( obj1 );</span>
&lt;A projective object in Category of f.p. graded left modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ZFree );</span>
A projective object in Freyd( Category of graded rows over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) )

Relation morphism:
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 0 and degrees:
[  ]

Matrix:
(an empty 0 x 1 matrix)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( ZFree );</span>
&lt;An identity morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id;</span>
&lt;A morphism in Category of f.p. graded left modules over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coker_proj := CokernelProjection( z );</span>
&lt;An epimorphism in Category of f.p. graded left modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cokernel_colift := CokernelColift( z, CokernelProjection( z ) );</span>
&lt;A morphism in Category of f.p. graded left modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := ZFree;</span>
&lt;A projective object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := obj_gamma;</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := TensorProductOnObjects( ZFree, obj_gamma );</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KaxbKxc := TensorProductOnObjects( TensorProductOnObjects( a, b ), c );</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( KaxbKxc, ZeroObject( freyd ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tensor_product_morphism := TensorProductOnMorphisms( cokernel_colift, coker_proj );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( tensor_product_morphism );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Source( tensor_product_morphism ), Range( tensor_product_morphism ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">unit := TensorUnit( freyd );</span>
&lt;An object in Category of f.p. graded left modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( TensorProductOnObjects( a, unit ), a );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">axKbxcK := TensorProductOnObjects( a, TensorProductOnObjects( b, c ) );</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_left_to_right := AssociatorLeftToRightWithGivenTensorProducts( KaxbKxc, a, b, c, axKbxcK );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( ass_left_to_right );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_right_to_left := AssociatorLeftToRightWithGivenTensorProducts( axKbxcK, a, b, c, KaxbKxc );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( ass_right_to_left );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( ass_right_to_left );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftUnitor( a );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftUnitorInverse( axKbxcK );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightUnitor( b );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightUnitorInverse( TensorProductOnObjects( axKbxcK, axKbxcK ) );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Braiding( axKbxcK, KaxbKxc );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">braiding := Braiding( a, b );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( braiding );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := InternalHomOnObjects( axKbxcK, axKbxcK );</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( hom );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">free_mod1 := AsFreydCategoryObject( GradedRow( [ [[0,0],1] ], S ) );</span>
&lt;A projective object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">free_mod2 := AsFreydCategoryObject( GradedRow( [ [[1,1],1] ], S ) );</span>
&lt;A projective object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom2 := InternalHomOnObjects( free_mod1, free_mod2 );</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( hom2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Source( RelationMorphism( hom2 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank( Range( RelationMorphism( hom2 ) ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom3 := InternalHomOnObjects( free_mod2, free_mod1 );</span>
&lt;An object in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( hom3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InternalHomOnMorphisms( ass_left_to_right, ass_right_to_left );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eval := EvaluationMorphism( a, b );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( eval );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( eval );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coeval := CoevaluationMorphism( a, b );</span>
&lt;A morphism in Category of f.p. graded left modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( coeval );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( coeval );</span>
true
</pre></div>

<p><a id="X7EFC6E1778B1A18D" name="X7EFC6E1778B1A18D"></a></p>

<h4>14.2 <span class="Heading">Freyd category of graded columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationalsInSingular();</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := GradedRing( Q * "x_1, x_2, x_3, x_4" );</span>
Q[x_1,x_2,x_3,x_4]
(weights: yet unset)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetWeightsOfIndeterminates( S, [[1,0],[1,0],[0,1],[0,1]] );</span>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CategoryOfGradedColumns( S );</span>
Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := GradedColumn( [ [[1,1],1] ], S );</span>
&lt;A graded column of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := GradedColumn( [ [[1,1],2] ], S );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := GradedRowOrColumnMorphism( obj2, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       HomalgMatrix( [ [ 1, 1 ], [ 1, 1 ] ], 2, 2, S ), obj2 );</span>
&lt;A morphism in Category of graded columns over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">freyd := FreydCategory( cat );</span>
Category of f.p. graded right modules over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelianCategory( freyd );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_gamma := FreydCategoryObject( gamma );</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreydCategoryMorphism( obj_gamma, gamma, obj_gamma );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">witness := MorphismWitness( f );</span>
&lt;A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( witness );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

Matrix:
2,2,
0,0 
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FreydCategoryMorphism( obj_gamma, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   ZeroMorphism( obj2, obj2 ), obj_gamma );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( f, g );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := PreCompose( f, f );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( c );</span>
A morphism in Category of f.p. graded right modules over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) )

--------------------------------

Source:
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

Matrix:
1,1,
1,1
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

--------------------------------

Morphism datum:
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

Matrix:
2,2,
2,2
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

--------------------------------

Range:
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

Matrix:
1,1,
1,1
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
of rank 2 and degrees:
[ [ ( 1, 1 ), 2 ] ]

--------------------------------
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := g + g;</span>
&lt;A morphism in Category of f.p. graded right modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := GradedRowOrColumnMorphism( obj1, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                 HomalgMatrix( [ [ 2 ] ], 1, 1, S ), obj1 );</span>
&lt;A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( a );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]

Matrix:
2
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z2 := FreydCategoryObject( a );</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Z2 );</span>
An object in Freyd( Category of graded columns over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) )

Relation morphism:
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]

Matrix:
2
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( Z2 );</span>
&lt;An identity morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id + id;</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := DirectSumFunctorial( [ z, z, z ] );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr2 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr3 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 3 );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">uni := UniversalMorphismIntoDirectSum( [ pr3, pr2 ] );</span>
&lt;A morphism in Category of f.p. graded right modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 1 );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">uni2 := UniversalMorphismFromDirectSum( [ inj2, inj1 ] );</span>
&lt;A morphism in Category of f.p. graded right modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZFree := AsFreydCategoryObject( obj1 );</span>
&lt;A projective object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ZFree );</span>
A projective object in Category of f.p. graded right modules over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) )

Relation morphism:
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 0 and degrees:
[  ]

Matrix:
(an empty 1 x 0 matrix)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees:
[ [ ( 1, 1 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( ZFree );</span>
&lt;An identity morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id;</span>
&lt;A morphism in Category of f.p. graded right modules over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coker_proj := CokernelProjection( z );</span>
&lt;An epimorphism in Category of f.p. graded right modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cokernel_colift := CokernelColift( z, CokernelProjection( z ) );</span>
&lt;A morphism in Category of f.p. graded right modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := ZFree;</span>
&lt;A projective object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := obj_gamma;</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := TensorProductOnObjects( a, b );</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KaxbKxc := TensorProductOnObjects( TensorProductOnObjects( a, b ), c );</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( KaxbKxc, ZeroObject( freyd ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tensor_product_morphism := TensorProductOnMorphisms( cokernel_colift, coker_proj );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( tensor_product_morphism );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Source( tensor_product_morphism ), Range( tensor_product_morphism ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">unit := TensorUnit( freyd );</span>
&lt;An object in Category of f.p. graded right modules over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( TensorProductOnObjects( a, unit ), a );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">axKbxcK := TensorProductOnObjects( a, TensorProductOnObjects( b, c ) );</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_left_to_right := AssociatorLeftToRightWithGivenTensorProducts( KaxbKxc, a, b, c, axKbxcK );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( ass_left_to_right );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_right_to_left := AssociatorLeftToRightWithGivenTensorProducts( axKbxcK, a, b, c, KaxbKxc );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( ass_right_to_left );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( ass_right_to_left );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftUnitor( a );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftUnitorInverse( axKbxcK );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightUnitor( b );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightUnitorInverse( TensorProductOnObjects( axKbxcK, axKbxcK ) );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Braiding( axKbxcK, KaxbKxc );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">braiding := Braiding( a, b );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( braiding );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := InternalHomOnObjects( axKbxcK, axKbxcK );</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( hom );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">free_mod1 := AsFreydCategoryObject( GradedColumn( [ [[0,0],1] ], S ) );</span>
&lt;A projective object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">free_mod2 := AsFreydCategoryObject( GradedColumn( [ [[1,1],1] ], S ) );</span>
&lt;A projective object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom2 := InternalHomOnObjects( free_mod1, free_mod2 );</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( hom2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Source( RelationMorphism( hom2 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rank( Range( RelationMorphism( hom2 ) ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom3 := InternalHomOnObjects( free_mod2, free_mod1 );</span>
&lt;An object in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( hom3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InternalHomOnMorphisms( ass_left_to_right, ass_right_to_left );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eval := EvaluationMorphism( a, b );</span>
&lt;A morphism in Category of f.p. graded right modules over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( eval );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( eval );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coeval := CoevaluationMorphism( a, b );</span>
&lt;A morphism in Category of f.p. graded right modules over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( coeval );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( coeval );</span>
true
</pre></div>

<p><a id="X783430D884689E27" name="X783430D884689E27"></a></p>

<h4>14.3 <span class="Heading">Constructors of objects and reduction of degree lists</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationalsInSingular();</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := GradedRing( Q * "x_1, x_2, x_3, x_4" );</span>
Q[x_1,x_2,x_3,x_4]
(weights: yet unset)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetWeightsOfIndeterminates( S, [[1,0],[1,0],[0,1],[0,1]] );</span>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectL := GradedRow( [ [[1,0],2] ], S );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DegreeList( ObjectL );</span>
[ [ ( 1, 0 ), 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Object2L := GradedRow( [ [[1,0],2], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [[1,0],3],[[0,1],2],[[1,0],1] ], S );</span>
&lt;A graded row of rank 8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DegreeList( Object2L );</span>
[ [ ( 1, 0 ), 5 ], [ ( 0, 1 ), 2 ], [ ( 1, 0 ), 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnzipDegreeList( Object2L );</span>
[ ( 1, 0 ), ( 1, 0 ), ( 1, 0 ), ( 1, 0 ), ( 1, 0 ), ( 0, 1 ), ( 0, 1 ), ( 1, 0 ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectR := GradedColumn( [ [[1,0],2] ], S );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DegreeList( ObjectR );</span>
[ [ ( 1, 0 ), 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Object2R := GradedColumn( [ [[1,0],2], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [[1,0],3],[[0,1],2],[[1,0],1] ], S );</span>
&lt;A graded column of rank 8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DegreeList( Object2R );</span>
[ [ ( 1, 0 ), 5 ], [ ( 0, 1 ), 2 ], [ ( 1, 0 ), 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnzipDegreeList( Object2R );</span>
[ ( 1, 0 ), ( 1, 0 ), ( 1, 0 ), ( 1, 0 ), ( 1, 0 ), ( 0, 1 ), ( 0, 1 ), ( 1, 0 ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2 := GradedRing( Q * "x" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetWeightsOfIndeterminates( S2, [ 1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( GradedRow( [ [ [ 1 ], 1 ] ], S2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( GradedColumn( [ [ [ 1 ], 1 ] ], S2 ) );</span>
true
</pre></div>

<p>Whenever the object constructor is called, it tries to simplify the given degree list. To this end it checks if subsequent degree group elements match. If so, their multiplicities are added. So, as in the example above we have:</p>

<p class="pcenter"> [ [(1,0),2], [(1,0),3],[(0,1),2],[(1,0),1] ] \mapsto [ [ ( 1, 0 ), 5 ], [ ( 0, 1 ), 2 ], [ ( 1, 0 ), 1 ] ] </p>

<p>Note that, even though there are two occurances of <span class="Math">\left( 1,0 \right)</span> in the final degree list, we do not simplify further. The reason for this is as follows. Assume that we have a map of graded rows</p>

<p class="pcenter"> \varphi \colon A \to B </p>

<p>given by a homomgeneous matrix <span class="Math">M</span> and that we want to compute the weak kernel embedding of this mapping. To this end we first compute the row syzygies of <span class="Math">M</span>. Let us call the corresponding matrix <span class="Math">N</span>. Then we deduce the degree list of the weak kernel object from <span class="Math">N</span> and from the graded row <span class="Math">A</span>. Once this degree list is known, we would call the object constructor. If this object constructor summarised all (and not only subsequent) occurances of one degree element in the degree list, then in order to make sure that the weak kernel embedding is a mapping of graded rows, the rows of the matrix <span class="Math">N</span> would have to be shuffled. The latter we do not wish to perform.</p>

<p>Note that the 'IsEqualForObjects' methods returns true whenever the degree lists of two graded rows/columns are identical. So in particular it returns false, if the degree lists are mere permutations of one another. Here is an example.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Object2LShuffle := GradedRow( [ [[0,1],1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [[1,0],2],[[0,1],1],[[1,0],4] ], S );</span>
&lt;A graded row of rank 8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Object2L, Object2LShuffle );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Object2RShuffle := GradedColumn( [ [[0,1],1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [[1,0],2],[[0,1],1],[[1,0],4] ], S );</span>
&lt;A graded column of rank 8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Object2R, Object2RShuffle );</span>
false
</pre></div>

<p><a id="X7A9CA0C983ECE36B" name="X7A9CA0C983ECE36B"></a></p>

<h4>14.4 <span class="Heading">Constructors of morphisms</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q1L := GradedRow( [ [[0,0],1] ], S );</span>
&lt;A graded row of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( Q1L );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q2L := GradedRow( [ [[1,0],2] ], S );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1L := GradedRowOrColumnMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Q1L, HomalgMatrix( [["x_1","x_2"]], S ) ,Q2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m1L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Source( m1L ) );</span>
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Range( m1L ) );</span>
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees: 
[ [ ( 1, 0 ), 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( m1L ) );</span>
x_1,x_2
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q1R := GradedColumn( [ [[0,0],1] ], S );</span>
&lt;A graded column of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( Q1R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q2R := GradedColumn( [ [[1,0],2] ], S );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1R := GradedRowOrColumnMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Q1R, HomalgMatrix( [["x_1"],["x_2"]], S ) ,Q2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m1R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Source( m1R ) );</span>
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 1 and degrees: 
[ [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Range( m1R ) );</span>
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees: 
[ [ ( 1, 0 ), 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( m1R ) );</span>
x_1,
x_2
(over a graded ring)
</pre></div>

<p><a id="X827E565A7F15C748" name="X827E565A7F15C748"></a></p>

<h4>14.5 <span class="Heading">The GAP categories</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">categoryL := CapCategory( Q1L );</span>
Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">categoryR := CapCategory( Q1R );</span>
Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])
</pre></div>

<p><a id="X7A34A184800E1DD6" name="X7A34A184800E1DD6"></a></p>

<h4>14.6 <span class="Heading">A few categorical constructions for graded rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroObject( categoryL );</span>
&lt;A graded row of rank 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O1L := GradedRow( [ [[-1,0],2] ], S );</span>
&lt;A graded row of rank 2&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ZeroMorphism( ZeroObject( categoryL ), O1L ) );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 0 and degrees: 
[  ]

Matrix:
(an empty 0 x 2 matrix)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ ( -1, 0 ), 2 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O2L := GradedRow( [ [[0,0],1] ], S );</span>
&lt;A graded row of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj3L := GradedRow( [ [[-1,0],1] ], S );</span>
&lt;A graded row of rank 1&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( IdentityMorphism( O2L ) );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]

Matrix:
1
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( IdentityMorphism( Q2L ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">directSumL := DirectSum( [ O1L, O2L ] );</span>
&lt;A graded row of rank 3&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( directSumL );</span>
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 3 and degrees:
[ [ ( -1, 0 ), 2 ], [ 0, 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i1L := InjectionOfCofactorOfDirectSum( [ O1L, O2L ], 1 );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( i1L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( i1L ) );</span>
1,0,0,
0,1,0 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i2L := InjectionOfCofactorOfDirectSum( [ O1L, O2L ], 2 );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ],[ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( i2L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( i2L ) );</span>
0,0,1
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">proj1L := ProjectionInFactorOfDirectSum( [ O1L, O2L ], 1 );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( proj1L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( proj1L ) );</span>
1,0,
0,1,
0,0 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">proj2L := ProjectionInFactorOfDirectSum( [ O1L, O2L ], 2 );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( proj2L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( proj2L ) );</span>
0,
0,
1 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kL := WeakKernelEmbedding( proj1L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( kL );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( kL ) );</span>
0,0,1
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ckL := WeakCokernelProjection( kL );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( ckL );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( ckL ) );</span>
1,0,
0,1,
0,0 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( kL );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( kL );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( ckL );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( ckL );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1L := GradedRowOrColumnMorphism( O1L, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      HomalgMatrix( [[ "x_1" ], [ "x_2" ]], S ), O2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m1L );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m2L := IdentityMorphism( O2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m2L );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1L := GradedRow( [ [[0,0],1], [[-1,0],1] ], S );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1L := GradedRowOrColumnMorphism( obj1L, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      HomalgMatrix( [[ 1 ], [ "x_2"] ], S ), O2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m1L );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m3L := GradedRowOrColumnMorphism( obj3L, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      HomalgMatrix( [[ "x_1" ]], S ), O2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m3L );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">liftL := Lift( m3L, m1L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( liftL );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( liftL ) );</span>
x_1, 0
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O3L := GradedRow( [ [[1,0],2] ], S );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">morL := GradedRowOrColumnMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       O2L, HomalgMatrix( [[ "x_1, x_2" ]], S ), O3L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( morL );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coliftL := Colift( m2L, morL );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( coliftL );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( coliftL ) );</span>
x_1,x_2
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fpL := WeakBiFiberProduct( m1L, m2L );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fp_proj1L := ProjectionInFirstFactorOfWeakBiFiberProduct( m1L, m2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( fp_proj1L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( fp_proj1L ) );</span>
1,0,
0,1 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fp_proj2L := ProjectionInSecondFactorOfWeakBiFiberProduct( m1L, m2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( fp_proj2L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( fp_proj2L ) );</span>
1,
x_2 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BiasedWeakFiberProduct( m1L, m2L );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pbwfprow := ProjectionOfBiasedWeakFiberProduct( m1L, m2L );</span>
&lt;A morphism in Category of graded rows over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( pbwfprow );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( pbwfprow );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ 0, 1 ], [ ( -1, 0 ), 1 ] ]

Matrix:
1,0,
0,1 
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ 0, 1 ], [ ( -1, 0 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poL := WeakBiPushout( morL, m2L );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1L := InjectionOfFirstCofactorOfWeakBiPushout( morL, m2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( inj1L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( inj1L ) );</span>
1,0,
0,1 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2L := InjectionOfSecondCofactorOfWeakBiPushout( morL, m2L );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( inj2L );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( inj2L ) );</span>
x_1,x_2
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">injectionL := InjectionOfBiasedWeakPushout( morL, m2L );</span>
&lt;A morphism in Category of graded rows over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( injectionL );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( injectionL );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees: 
[ [ ( 1, 0 ), 2 ] ]

Matrix:
1,0,
0,1 
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ ( 1, 0 ), 2 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tensorProductL := TensorProductOnObjects( O1L, O2L );</span>
&lt;A graded row of rank 2&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tensorProductL );</span>
A graded row over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees: 
[ [ ( -1, 0 ), 2 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tensorProductMorphismL := TensorProductOnMorphisms( m2L, morL );</span>
&lt;A morphism in Category of graded rows over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( tensorProductMorphismL );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tensorProductMorphismL );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]

Matrix:
x_1,x_2
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ ( 1, 0 ), 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( DualOnObjects( TensorProductOnObjects( ObjectL, Object2L ) ) );</span>
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 16 and degrees: 
[ [ ( -2, 0 ), 5 ], [ ( -1, -1 ), 2 ], [ ( -2, 0 ), 6 ], [ ( -1, -1 ), 2 ], 
[ ( -2, 0 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( DualOnMorphisms( m1L ) );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( DualOnMorphisms( m1L ) );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]

Matrix:
1,x_2
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ 0, 1 ], [ ( 1, 0 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( EvaluationForDualWithGivenTensorProduct( TensorProductOnObjects( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">DualOnObjects( ObjectL ), ObjectL ), ObjectL, TensorUnit( categoryL ) ) );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( EvaluationForDualWithGivenTensorProduct( TensorProductOnObjects( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">DualOnObjects( ObjectL ), ObjectL ), ObjectL, TensorUnit( categoryL ) ) );</span>
A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded row over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 4 and degrees: 
[ [ 0, 4 ] ]

Matrix:
1,
0,
0,
1 
(over a graded ring)

Range:
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( InternalHomOnObjects( ObjectL, ObjectL ) );</span>
A graded row over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 4 and degrees: 
[ [ 0, 4 ] ]
</pre></div>

<p><a id="X7E3CC2FB7DD5B4F8" name="X7E3CC2FB7DD5B4F8"></a></p>

<h4>14.7 <span class="Heading">A few categorical constructions for graded columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroObject( categoryR );</span>
&lt;A graded column of rank 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O1R := GradedColumn( [ [[-1,0],2] ], S );</span>
&lt;A graded column of rank 2&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ZeroMorphism( ZeroObject( categoryR ), O1R ) );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1,0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 0 and degrees: 
[  ]

Matrix:
(an empty 2 x 0 matrix)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1,0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ ( -1, 0 ), 2 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O2R := GradedColumn( [ [[0,0],1] ], S );</span>
&lt;A graded column of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj3R := GradedColumn( [ [[-1,0],1] ], S );</span>
&lt;A graded column of rank 1&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( IdentityMorphism( O2R ) );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]

Matrix:
1
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( IdentityMorphism( Q2R ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">directSumR := DirectSum( [ O1R, O2R ] );</span>
&lt;A graded column of rank 3&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( directSumR );</span>
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 3 and degrees:
[ [ ( -1, 0 ), 2 ], [ 0, 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i1R := InjectionOfCofactorOfDirectSum( [ O1R, O2R ], 1 );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( i1R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( i1R ) );</span>
1,0,
0,1,
0,0
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i2R := InjectionOfCofactorOfDirectSum( [ O1R, O2R ], 2 );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ],[ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( i2R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( i2R ) );</span>
0,
0,
1
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">proj1R := ProjectionInFactorOfDirectSum( [ O1R, O2R ], 1 );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( proj1R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( proj1R ) );</span>
1,0,0,
0,1,0
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">proj2R := ProjectionInFactorOfDirectSum( [ O1R, O2R ], 2 );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( proj2R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( proj2R ) );</span>
0,0,1
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kR := WeakKernelEmbedding( proj1R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( kR );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( kR ) );</span>
0,
0,
1
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ckR := WeakCokernelProjection( kR );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( ckR );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( ckR ) );</span>
1,0,0,
0,1,0
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( kR );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( kR );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( ckR );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( ckR );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1R := GradedRowOrColumnMorphism( O1R, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      HomalgMatrix( [[ "x_1", "x_2" ]], S ), O2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m1R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m2R := IdentityMorphism( O2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m2R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1R := GradedColumn( [ [[0,0],1], [[-1,0],1] ], S );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1R := GradedRowOrColumnMorphism( obj1R, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      HomalgMatrix( [ [ 1, "x_2"] ], S ), O2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m1R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m3R := GradedRowOrColumnMorphism( obj3R, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      HomalgMatrix( [[ "x_1" ]], S ), O2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m3R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">liftR := Lift( m3R, m1R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( liftR );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( liftR ) );</span>
x_1,
0
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O3R := GradedColumn( [ [[1,0],2] ], S );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">morR := GradedRowOrColumnMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       O2R, HomalgMatrix( [[ "x_1" ], [ "x_2" ]], S ), O3R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( morR );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coliftR := Colift( m2R, morR );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( coliftR );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( coliftR ) );</span>
x_1,
x_2
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fpR := WeakBiFiberProduct( m1R, m2R );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fp_proj1R := ProjectionInFirstFactorOfWeakBiFiberProduct( m1R, m2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( fp_proj1R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( fp_proj1R ) );</span>
1,0,
0,1 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fp_proj2R := ProjectionInSecondFactorOfWeakBiFiberProduct( m1R, m2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( fp_proj2R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( fp_proj2R ) );</span>
1, x_2
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BiasedWeakFiberProduct( m1R, m2R );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pbwfpcol := ProjectionOfBiasedWeakFiberProduct( m1R, m2R );</span>
&lt;A morphism in Category of graded columns over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( pbwfpcol );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( pbwfpcol );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ 0, 1 ], [ ( -1, 0 ), 1 ] ]

Matrix:
1,0,
0,1 
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ 0, 1 ], [ ( -1, 0 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poR := WeakBiPushout( morR, m2R );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1R := InjectionOfFirstCofactorOfWeakBiPushout( morR, m2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( inj1R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( inj1R ) );</span>
1,0,
0,1 
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2R := InjectionOfSecondCofactorOfWeakBiPushout( morR, m2R );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( inj2R );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingHomalgMatrix( inj2R ) );</span>
x_1,
x_2
(over a graded ring)
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">injectionR := InjectionOfBiasedWeakPushout( morR, m2R );</span>
&lt;A morphism in Category of graded columns over
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( injectionR );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( injectionR );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ ( 1, 0 ), 2 ] ]

Matrix:
1,0,
0,1 
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ ( 1, 0 ), 2 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tensorProductR := TensorProductOnObjects( O1R, O2R );</span>
&lt;A graded column of rank 2&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tensorProductR );</span>
A graded column over Q[x_1,x_2,x_3,x_4] (with weights 
[ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 2 and degrees: 
[ [ ( -1, 0 ), 2 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tensorProductMorphismR := TensorProductOnMorphisms( m2R, morR );</span>
&lt;A morphism in Category of graded columns over 
Q[x_1,x_2,x_3,x_4] (with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( tensorProductMorphismR );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( tensorProductMorphismR );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]

Matrix:
x_1,
x_2 
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ ( 1, 0 ), 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( DualOnObjects( TensorProductOnObjects( ObjectR, Object2R ) ) );</span>
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) of rank 16 and degrees: 
[ [ ( -2, 0 ), 5 ], [ ( -1, -1 ), 2 ], [ ( -2, 0 ), 6 ], [ ( -1, -1 ), 2 ], 
[ ( -2, 0 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( DualOnMorphisms( m1R ) );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( DualOnMorphisms( m1R ) );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]

Matrix:
1, 
x_2
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 2 and degrees: 
[ [ 0, 1 ], [ ( 1, 0 ), 1 ] ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( EvaluationForDualWithGivenTensorProduct( TensorProductOnObjects( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">DualOnObjects( ObjectR ), ObjectR ), ObjectR, TensorUnit( categoryR ) ) );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( EvaluationForDualWithGivenTensorProduct( TensorProductOnObjects( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">DualOnObjects( ObjectR ), ObjectR ), ObjectR, TensorUnit( categoryR ) ) );</span>
A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])

Source:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 4 and degrees: 
[ [ 0, 4 ] ]

Matrix:
1,0,0,1
(over a graded ring)

Range:
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 1 and degrees: 
[ [ 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( InternalHomOnObjects( ObjectR, ObjectR ) );</span>
A graded column over Q[x_1,x_2,x_3,x_4] 
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ]) 
of rank 4 and degrees: 
[ [ 0, 4 ] ]
</pre></div>

<p><a id="X7D4C656384F41D31" name="X7D4C656384F41D31"></a></p>

<h4>14.8 <span class="Heading">Additional examples on monoidal structure for graded rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aR := GradedRow( [ [ [1,0], 1 ] ], S );</span>
&lt;A graded row of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bR := ZeroObject( CapCategory( aR ) );</span>
&lt;A graded row of rank 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coevR := CoevaluationForDual( bR );</span>
&lt;A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( coevR );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">evalR := EvaluationForDual( bR );</span>
&lt;A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( evalR );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cR := GradedRow( [ [ [2,0], 1 ] ], S );</span>
&lt;A graded row of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aR_o_bR := TensorProductOnObjects( aR, bR );</span>
&lt;A graded row of rank 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phiR := ZeroMorphism( aR_o_bR, cR );</span>
&lt;A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( phiR );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tens_mor := TensorProductToInternalHomAdjunctionMap(aR,bR,phiR);</span>
&lt;A morphism in Category of graded rows over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( tens_mor );</span>
true
</pre></div>

<p><a id="X83218D197FAD5A73" name="X83218D197FAD5A73"></a></p>

<h4>14.9 <span class="Heading">Additional examples on monoidal structure for graded columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aC := GradedColumn( [ [ [1,0], 1 ] ], S );</span>
&lt;A graded column of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bC := ZeroObject( CapCategory( aC ) );</span>
&lt;A graded column of rank 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coevC := CoevaluationForDual( bC );</span>
&lt;A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( coevC );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">evalC := EvaluationForDual( bC );</span>
&lt;A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( evalC );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cC := GradedColumn( [ [ [2,0], 1 ] ], S );</span>
&lt;A graded column of rank 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aC_o_bC := TensorProductOnObjects( aC, bC );</span>
&lt;A graded column of rank 0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phiC := ZeroMorphism( aC_o_bC, cC );</span>
&lt;A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( phiC );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tens_mor := TensorProductToInternalHomAdjunctionMap(aC,bC,phiC);</span>
&lt;A morphism in Category of graded columns over Q[x_1,x_2,x_3,x_4]
(with weights [ [ 1, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 1 ] ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( tens_mor );</span>
true
</pre></div>

<p><a id="X78BBD81679376CA5" name="X78BBD81679376CA5"></a></p>

<h4>14.10 <span class="Heading">Examples to test Tools methods in graded rows/cols</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := GradedRing( Q * "x,y" );</span>
Q[x,y]
(weights: yet unset)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetWeightsOfIndeterminates( S, [ 1, 1 ] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat_1 := HomalgMatrix( "[ x, 0, 0, y ]", 2, 2, S );</span>
&lt;A 2 x 2 matrix over a graded ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat_2 := HomalgMatrix( "[ x, 0, 0, 0 ]", 2, 2, S );</span>
&lt;A 2 x 2 matrix over a graded ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := GradedRow( [ [ [ 1 ], 1 ], [ [ 2 ], 1 ] ], S );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := GradedColumn( [ [ [ 1 ], 1 ], [ [ 2 ], 1 ] ], S );</span>
&lt;A graded column of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := DeduceMapFromMatrixAndRangeForGradedRows( mat_1, a );</span>
&lt;A morphism in Category of graded rows over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">some_map := DeduceSomeMapFromMatrixAndRangeForGradedRows( mat_1, a );</span>
&lt;A morphism in Category of graded rows over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( map, some_map );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := DeduceMapFromMatrixAndSourceForGradedRows( mat_1, a );</span>
&lt;A morphism in Category of graded rows over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">some_map := DeduceSomeMapFromMatrixAndSourceForGradedRows( mat_1, a );</span>
&lt;A morphism in Category of graded rows over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( map, some_map );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">some_map := DeduceSomeMapFromMatrixAndRangeForGradedRows( mat_2, a );</span>
&lt;A morphism in Category of graded rows over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( some_map );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">some_map := DeduceSomeMapFromMatrixAndSourceForGradedRows( mat_2, a );</span>
&lt;A morphism in Category of graded rows over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( some_map );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := DeduceMapFromMatrixAndRangeForGradedCols( mat_1, b );</span>
&lt;A morphism in Category of graded columns over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">some_map := DeduceSomeMapFromMatrixAndRangeForGradedCols( mat_1, b );</span>
&lt;A morphism in Category of graded columns over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( map, some_map );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := DeduceMapFromMatrixAndSourceForGradedCols( mat_1, b );</span>
&lt;A morphism in Category of graded columns over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">some_map := DeduceSomeMapFromMatrixAndSourceForGradedCols( mat_1, b );</span>
&lt;A morphism in Category of graded columns over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( map, some_map );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">some_map := DeduceSomeMapFromMatrixAndRangeForGradedCols( mat_2, b );</span>
&lt;A morphism in Category of graded columns over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( some_map );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">some_map := DeduceSomeMapFromMatrixAndSourceForGradedCols( mat_2, b );</span>
&lt;A morphism in Category of graded columns over Q[x,y] (with weights [ 1, 1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( some_map );</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap13.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap15.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
