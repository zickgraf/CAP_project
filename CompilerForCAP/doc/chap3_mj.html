<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (CompilerForCAP) - Chapter 3: Examples and tests</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapInd_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3.html">[MathJax off]</a></p>
<p><a id="X7967FE8E7BBDF485" name="X7967FE8E7BBDF485"></a></p>
<div class="ChapSects"><a href="chap3_mj.html#X7967FE8E7BBDF485">3 <span class="Heading">Examples and tests</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7A489A5D79DA9E5C">3.1 <span class="Heading">Examples</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7A810CDA83F2897F">3.2 <span class="Heading">Tests</span></a>
</span>
</div>
</div>

<h3>3 <span class="Heading">Examples and tests</span></h3>

<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>

<h4>3.1 <span class="Heading">Examples</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := MatrixCategory( Q : enable_compilation := true );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := VectorSpaceObject( 2, Q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := ZeroMorphism( V, V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := IdentityMorphism( V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W := DirectSum( V, V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">morphism_matrix := [ [ alpha, beta ], [ beta, alpha ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># compile the primitive installation of</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># MorphismBetweenDirectSumsWithGivenDirectSums</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">MorphismBetweenDirectSumsWithGivenDirectSums(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    W,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ V, V ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    morphism_matrix,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ V, V ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    W</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree1 := SYNTAX_TREE(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec!.compiled_functions.MorphismBetweenDirectSumsWithGivenDirectSums[3]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( SYNTAX_TREE_CODE( tree1 ) );</span>
function ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := UnderlyingRing( cat_1 );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, S_1, T_1, UnderlyingMatrix, 
       UnionOfRows( UnderlyingRing( cat_1 ), Dimension( T_1 ), 
         ListN( diagram_S_1, List( morphism_matrix_1, function ( row_2 )
                  return List( row_2, UnderlyingMatrix );
              end ), function ( source_2, row_2 )
                return UnionOfColumns( cap_jit_hoisted_expression_1_1, 
                   Dimension( source_2 ), row_2 );
            end ) ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># compile the default derivation of</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># MorphismBetweenDirectSumsWithGivenDirectSums</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">tree2 := SYNTAX_TREE( CapJitCompiledFunction(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ vec, W, [ V, V ], morphism_matrix, [ V, V ], W  ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( SYNTAX_TREE_CODE( tree2 ) );</span>
function ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := UnderlyingRing( cat_1 );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, S_1, T_1,  UnderlyingMatrix, 
       UnionOfRows( UnderlyingRing( cat_1 ), Dimension( T_1 ), 
         ListN( diagram_S_1, morphism_matrix_1, 
           function ( logic_new_func_x_2, logic_new_func_y_2 )
                return UnionOfColumns( cap_jit_hoisted_expression_1_1, 
                   Dimension( logic_new_func_x_2 ), 
                   List( logic_new_func_y_2, function ( s_3 )
                          return UnderlyingMatrix( s_3 );
                      end ) );
            end ) ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KernelEmbedding( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Last( vec!.compiled_functions.KernelEmbedding ) );</span>
function ( cat_1, morphism_1 )
    local cap_jit_morphism_attribute_1;
    cap_jit_morphism_attribute_1 
     := SyzygiesOfRows( UnderlyingMatrix( morphism_1 ) );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, ObjectifyObjectForCAPWithAttributes( rec(
             ), cat_1, Dimension, NrRows( cap_jit_morphism_attribute_1 ) ), 
       Source( morphism_1 ), UnderlyingMatrix, cap_jit_morphism_attribute_1 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># be careful not to use `MatrixCategory` because attributes are not supported</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">category_constructor := field -&gt; MATRIX_CATEGORY( field );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">given_arguments := [ QQ ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_category_name := "MatrixCategoryPrecompiled";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">package_name := "LinearAlgebraForCAP";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Intersection(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ListInstalledOperationsOfCategory( category_constructor( QQ ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CAP_JIT_INTERNAL_SAFE_OPERATIONS</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># exclude some operations which currently do not yield nice results</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">operations := Filtered( operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        o -&gt; PositionSublist( o, "FiberProduct" ) = fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Filtered( operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        o -&gt; PositionSublist( o, "Pushout" ) = fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Filtered( operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        o -&gt; PositionSublist( o, "Image" ) = fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Filtered( operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        o -&gt; PositionSublist( o, "Coimage" ) = fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Filtered( operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        o -&gt; PositionSublist( o, "DirectProduct" ) = fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Filtered( operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        o -&gt; PositionSublist( o, "Coproduct" ) = fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Filtered( operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        o -&gt; PositionSublist( o, "TerminalObject" ) = fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Filtered( operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        o -&gt; PositionSublist( o, "InitialObject" ) = fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "DirectSumCodiagonalDifference" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "DirectSumDiagonalDifference" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "HomologyObject" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "LiftOrFail", "ColiftOrFail" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># IsEqualForMorphismsOnMor causes problems in GAP 4.11 (see GAP issue #4449)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "IsEqualForMorphismsOnMor" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "IsIdenticalToIdentityMorphism" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "IsIdenticalToZeroMorphism" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># IsZeroForMorphisms tries to resolve IsZero and IsZero has a new</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># installation in GAP 4.12, so this causes slight differences in the output</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "IsZeroForMorphisms" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( operations, "DirectSumFunctorialWithGivenDirectSums" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    given_arguments,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    package_name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    compiled_category_name :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    operations := operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatrixCategoryPrecompiled( QQ );</span>
Category of matrices over Q
</pre></div>

<p><a id="X7A810CDA83F2897F" name="X7A810CDA83F2897F"></a></p>

<h4>3.2 <span class="Heading">Tests</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_DROP_NEXT_STATEMENT</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Display( 1 ); return 1; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, [ ] ) );</span>
function ( )
    return 1;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := MatrixCategory( Q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MyKernelLift := function( cat, mor, test_mor )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return LiftOrFail( cat, test_mor, KernelEmbedding( cat, mor ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := VectorSpaceObject( 2, Q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := CapJitCompiledFunction(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    MyKernelLift,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ rows, ZeroMorphism( V, V ), IdentityMorphism( V ) ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( cat_1, mor_1, test_mor_1 )
    local cap_jit_morphism_attribute_1;
    cap_jit_morphism_attribute_1 
     := RightDivide( UnderlyingMatrix( test_mor_1 ), 
       SyzygiesOfRows( UnderlyingMatrix( mor_1 ) ) );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, Source( test_mor_1 ), 
       ObjectifyObjectForCAPWithAttributes( rec(
             ), cat_1, Dimension, NrColumns( cap_jit_morphism_attribute_1 ) )
        , UnderlyingMatrix, cap_jit_morphism_attribute_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func1 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x = 1 then return fail; fi; return 1; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func2 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x = 1 then return fail; else return 1; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">call_func1 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return func1( x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">call_func2 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return func2( x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( call_func1, [ 2 ] ) );</span>
function ( x_1 )
    return 1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( call_func2, [ 2 ] ) );</span>
function ( x_1 )
    return 1;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hoisting with deduplication</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; (y + (x + 1)) + (y + (x + 1)) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := x_1 + 1;
    return List( [ 1 .. 9 ], function ( y_2 )
            return y_2 + cap_jit_hoisted_expression_1_1 
              + (y_2 + cap_jit_hoisted_expression_1_1);
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hoisting of whole functions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; y + List( [ 1 .. 9 ], z -&gt; x + z ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := List( [ 1 .. 9 ], function ( z_2 )
            return x_1 + z_2;
        end );
    return List( [ 1 .. 9 ], function ( y_2 )
            return y_2 + cap_jit_hoisted_expression_1_1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># no hoisting of constants</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; y + 1 ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    return List( [ 1 .. 9 ], function ( y_2 )
            return y_2 + 1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hoisting of returned expressions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; x + 1 ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := x_1 + 1;
    return List( [ 1 .. 9 ], function ( y_2 )
            return cap_jit_hoisted_expression_1_1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hoisting of assigned expressions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], function( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        local z; z := x + 1; return z; end ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := x_1 + 1;
    return List( [ 1 .. 9 ], function ( y_2 )
            local z_2;
            z_2 := cap_jit_hoisted_expression_1_1;
            return z_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hosted expressions inside hosted expressions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], function( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return List( [ 1 .. 9 ], z -&gt; z + (1 + 1) ); end ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local cap_jit_hoisted_expression_1_1, cap_jit_hoisted_expression_2_1;
    cap_jit_hoisted_expression_1_1 := 1 + 1;
    cap_jit_hoisted_expression_2_1 := List( [ 1 .. 9 ], function ( z_2 )
            return z_2 + cap_jit_hoisted_expression_1_1;
        end );
    return List( [ 1 .. 9 ], function ( y_2 )
            return cap_jit_hoisted_expression_2_1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># deduplication of more complex trees, e.g. functions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], function( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return (y + Sum( list, a -&gt; a )) + Sum( list, a -&gt; a ); end ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( list_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := Sum( list_1, function ( a_2 )
            return a_2;
        end );
    return List( [ 1 .. 9 ], function ( y_2 )
            return y_2 + cap_jit_hoisted_expression_1_1 
              + cap_jit_hoisted_expression_1_1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hosting of expressions in lists, e.g. function call arguments</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x, func )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; func( x + 1, x + 1, y ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1, func_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := x_1 + 1;
    return List( [ 1 .. 9 ], function ( y_2 )
            return func_1( cap_jit_hoisted_expression_1_1, 
               cap_jit_hoisted_expression_1_1, y_2 );
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># restrict hoisting to if/else branches (where possible)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x &lt; 0 then return 0; else return y -&gt; [ x + 1, z -&gt; y + 1 ]; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDetectedTernaryConditionalExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local cap_jit_hoisted_expression_1_1;
    if x_1 &lt; 0 then
        return 0;
    else
        cap_jit_hoisted_expression_1_1 := x_1 + 1;
        return function ( y_2 )
              local cap_jit_hoisted_expression_2_2;
              cap_jit_hoisted_expression_2_2 := y_2 + 1;
              return [ cap_jit_hoisted_expression_1_1, function ( z_3 )
                        return cap_jit_hoisted_expression_2_2;
                    end ];
          end;
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x &lt; 0 then return y -&gt; [ x + 1, z -&gt; y + 1 ]; else return 0; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDetectedTernaryConditionalExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local cap_jit_hoisted_expression_1_1;
    if x_1 &lt; 0 then
        cap_jit_hoisted_expression_1_1 := x_1 + 1;
        return function ( y_2 )
              local cap_jit_hoisted_expression_2_2;
              cap_jit_hoisted_expression_2_2 := y_2 + 1;
              return [ cap_jit_hoisted_expression_1_1, function ( z_3 )
                        return cap_jit_hoisted_expression_2_2;
                    end ];
          end;
    else
        return 0;
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  if x &lt; 0 then return y -&gt; [ y, x+1 ]; else return y -&gt; [ y, x+1 ]; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDetectedTernaryConditionalExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local cap_jit_hoisted_expression_1_1;
    cap_jit_hoisted_expression_1_1 := x_1 + 1;
    if x_1 &lt; 0 then
        return function ( y_2 )
              return [ y_2, cap_jit_hoisted_expression_1_1 ];
          end;
    else
        return function ( y_2 )
              return [ y_2, cap_jit_hoisted_expression_1_1 ];
          end;
    fi;
    return;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MY_ID_FUNC := x -&gt; x;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func1 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x = 1 then return 1; else return 2; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree1 := ENHANCED_SYNTAX_TREE( func1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree1 := CapJitDetectedTernaryConditionalExpressions( tree1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree1.stats.statements.1.obj.type = "EXPR_CONDITIONAL";</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coded_func1 := ENHANCED_SYNTAX_TREE_CODE( tree1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">String( func1 ) = ReplacedString( String( coded_func1 ), "_1", "" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    type := "EXPR_FUNC",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    id := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    nams := [ ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    narg := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    nloc := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variadic := false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    stats := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        type := "STAT_SEQ_STAT",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        statements := AsSyntaxTreeList( [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                type := "STAT_RETURN_OBJ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                obj := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    type := "EXPR_FUNCCALL",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    funcref := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        type := "EXPR_REF_GVAR",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        gvar := "MY_ID_FUNC",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    args := AsSyntaxTreeList( [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            type := "EXPR_CONDITIONAL",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            condition := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                type := "EXPR_FALSE",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            expr_if_true := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                type := "EXPR_INT",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                value := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            expr_if_false := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                type := "EXPR_INT",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                value := 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coded_func2 := ENHANCED_SYNTAX_TREE_CODE( tree2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( coded_func2 );</span>
function (  )
    return MY_ID_FUNC( function (  )
              if false then
                  return 1;
              else
                  return 2;
              fi;
              return;
          end(  ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coded_func2();</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we have to work hard to not write semicolons so AutoDoc</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># does not begin a new statement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func3 := EvalString( ReplacedString( """function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local inner_func@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    inner_func := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      local y@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if x then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            y := 2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return y@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return MY_ID_FUNC( inner_func( ) )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func3 := CapJitCompiledFunction( func3, [ true ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func3 );</span>
function ( x_1 )
    if x_1 then
        return MY_ID_FUNC( 1 );
    else
        return MY_ID_FUNC( 2 );
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func4 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local y; if x then return 1; else return 1; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func4 := CapJitCompiledFunction( func4, [ true ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func4 );</span>
function ( x_1 )
    return 1;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KeyDependentOperation( "MyKeyDependentOperation",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       IsGroup, IsInt, ReturnTrue );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( MyKeyDependentOperationOp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ IsGroup, IsInt ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    function( G, int )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return int; end );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MyKeyDependentOperation( G, 2 ) = 2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MyFunction := G -&gt; MyKeyDependentOperation( G, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := CapJitCompiledFunction( MyFunction, [ G ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( G_1 )
    return 2;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">logic_templates_orig := ShallowCopy( CAP_JIT_LOGIC_TEMPLATES );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GUARD_STRING := "\"THIS_STRING_SHOULD_NEVER_APPEAR_IN_PRODUCTION_CODE\"";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># add a nonsense template</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">logic_template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "variable" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "x -&gt; x + variable + x - x",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := Concatenation( "x -&gt; x + variable + ", GUARD_STRING ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    returns_value := true,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitAddLogicTemplate( logic_template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( a )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return b -&gt; b + ( 2 * b + a ) + b - b; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, [ ] ) );</span>
function ( a_1 )
    return function ( b_2 )
          return b_2 + (2 * b_2 + a_1) 
            + "THIS_STRING_SHOULD_NEVER_APPEAR_IN_PRODUCTION_CODE";
      end;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that functions can be used multiple times in dst_template</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># add a nonsense template</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">CapJitAddLogicTemplate(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        variable_names := [ "list", "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        src_template := "List( list, l -&gt; value )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        dst_template := "Sum( list, l -&gt; value ) + Sum( list, l -&gt; value )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        returns_value := true,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( list, l -&gt; l ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we are not interested in the output, but only that this does not throw</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># an error due to some function id being used multiple times</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">CapJitCompiledFunction( func, [ ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( list, l -&gt; (x -&gt; x) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we are not interested in the output, but only that this does not throw</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># an error due to some function id being used multiple times</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">CapJitCompiledFunction( func, [ ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># reset CAP_JIT_LOGIC_TEMPLATES</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">MakeReadWriteGlobal( "CAP_JIT_LOGIC_TEMPLATES" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_LOGIC_TEMPLATES  := logic_templates_orig;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MakeReadOnlyGlobal( "CAP_JIT_LOGIC_TEMPLATES" );</span>
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQxy := QQ * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EEE := KoszulDualRing( QQxy );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns := function( homalg_ring, name )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        homalg_ring -&gt; CategoryOfColumnsAsOppositeOfCategoryOfRows(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            homalg_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ homalg_ring ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "CategoryOfColumnsAsOppositeOfCategoryOfRowsOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "Precompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        operations := "primitive"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( QQ, "Field" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( QQxy, "CommutativeRing" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( EEE, "ArbitraryRing" );;</span>
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># be careful not to use `MatrixCategory` because attributes are not supported</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">category_constructor := function( field )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return Opposite( MATRIX_CATEGORY(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        field :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        FinalizeCategory := true,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        enable_compilation := false</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">given_arguments := [ QQ ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_category_name := "OppositeOfMatrixCategoryPrecompiled";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">package_name := "LinearAlgebraForCAP";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := Intersection(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ListPrimitivelyInstalledOperationsOfCategory( MatrixCategory( QQ ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CAP_JIT_INTERNAL_SAFE_OPERATIONS</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># The output for Lift/ColiftOrFail differs between GAP 4.11 and GAP 4.12, see</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># https://github.com/gap-system/gap/issues/4523</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">operations := Difference( operations, [ "LiftOrFail", "ColiftOrFail" ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    given_arguments,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    package_name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    compiled_category_name :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    operations := operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "LinearAlgebraForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "gap/precompiled_categories/OppositeOfMatrixCategoryPrecompiled.gi"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OppositeOfMatrixCategoryPrecompiled( QQ );</span>
Opposite of Category of matrices over Q
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := MATRIX_CATEGORY( Q : enable_compilation := true );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( cat, x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return ZeroObject( cat ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># make sure that ZeroObject( cat ) is not resolved to a global variable</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( { cat, x } -&gt; func( cat, x ), [ vec ] ) );</span>
function ( cat_1, x_1 )
    return ObjectifyObjectForCAPWithAttributes( rec(
           ), cat_1, Dimension, 0 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local x; x := { args... } -&gt; 1; return x( ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, [ ] ) );</span>
function ( )
    return 1;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func1 := function( x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return x; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func2 := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local var; var := 1; var := func1( 2, var ); return var; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := CapJitCompiledFunction( func2, [] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func();</span>
2
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local id; id := y -&gt; y; return [ id, id ]; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we are not interested in the output, but only that this does not throw</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># an error due to some function id being used multiple times</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">CapJitCompiledFunction( func, [ ] );;</span>
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapInd_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
