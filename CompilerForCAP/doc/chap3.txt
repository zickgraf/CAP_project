  
  [1X3 [33X[0;0YExamples and tests[133X[101X
  
  
  [1X3.1 [33X[0;0YExamples[133X[101X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# make tests deterministic[127X[104X
    [4X[25X>[125X [27Xoriginal_func_id := CAP_JIT_INTERNAL_FUNCTION_ID;;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := 1;;[127X[104X
    [4X[25Xgap>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local a, b, c, d, e, f, g@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    a := 1@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x < 0 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        b := 2@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        c := 3@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    elif x = 1 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        c := b@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    else[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        d := a@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        c := a@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    e := c@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x < 0 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return a@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    elif x = 1 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return c@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    else[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        f := d@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        g := f@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return g@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrettyPrintSyntaxTree( tree );[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  0_type := "EXPR_DECLARATIVE_FUNC",[128X[104X
    [4X[28X  1_id := 1,[128X[104X
    [4X[28X  2_nams := [ "x", "a", "b", "c", "d", "e", "f", "g", "RETURN_VALUE" ],[128X[104X
    [4X[28X  3_narg := 1,[128X[104X
    [4X[28X  4_variadic := false,[128X[104X
    [4X[28X  5_bindings := rec([128X[104X
    [4X[28X      0_type := "FVAR_BINDING_SEQ",[128X[104X
    [4X[28X      1_names := [ "RETURN_VALUE", "a", "b", "c", "d", "e", "f", "g" ],[128X[104X
    [4X[28X      2_BINDING_RETURN_VALUE := rec([128X[104X
    [4X[28X          0_type := "EXPR_CASE",[128X[104X
    [4X[28X          1_branches := rec([128X[104X
    [4X[28X              0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X              0_length := 3,[128X[104X
    [4X[28X              1 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_LT",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 0 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "a" ) ),[128X[104X
    [4X[28X              2 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_EQ",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 1 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "c" ) ),[128X[104X
    [4X[28X              3 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "g" ) ) ) ),[128X[104X
    [4X[28X      3_BINDING_a := rec([128X[104X
    [4X[28X          0_type := "EXPR_INT",[128X[104X
    [4X[28X          1_value := 1 ),[128X[104X
    [4X[28X      4_BINDING_b := rec([128X[104X
    [4X[28X          0_type := "EXPR_INT",[128X[104X
    [4X[28X          1_value := 2 ),[128X[104X
    [4X[28X      5_BINDING_c := rec([128X[104X
    [4X[28X          0_type := "EXPR_CASE",[128X[104X
    [4X[28X          1_branches := rec([128X[104X
    [4X[28X              0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X              0_length := 3,[128X[104X
    [4X[28X              1 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_LT",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 0 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_INT",[128X[104X
    [4X[28X                      1_value := 3 ) ),[128X[104X
    [4X[28X              2 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_EQ",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 1 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "b" ) ),[128X[104X
    [4X[28X              3 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "a" ) ) ) ),[128X[104X
    [4X[28X      6_BINDING_d := rec([128X[104X
    [4X[28X          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X          1_func_id := 1,[128X[104X
    [4X[28X          2_name := "a" ),[128X[104X
    [4X[28X      7_BINDING_e := rec([128X[104X
    [4X[28X          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X          1_func_id := 1,[128X[104X
    [4X[28X          2_name := "c" ),[128X[104X
    [4X[28X      8_BINDING_f := rec([128X[104X
    [4X[28X          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X          1_func_id := 1,[128X[104X
    [4X[28X          2_name := "d" ),[128X[104X
    [4X[28X      9_BINDING_g := rec([128X[104X
    [4X[28X          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X          1_func_id := 1,[128X[104X
    [4X[28X          2_name := "f" ) ) )[128X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local a_1, b_1, c_1, d_1, e_1, f_1, g_1;[128X[104X
    [4X[28X    a_1 := 1;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        c_1 := 3;[128X[104X
    [4X[28X    elif x_1 = 1 then[128X[104X
    [4X[28X        b_1 := 2;[128X[104X
    [4X[28X        c_1 := b_1;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        c_1 := a_1;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        return a_1;[128X[104X
    [4X[28X    elif x_1 = 1 then[128X[104X
    [4X[28X        return c_1;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        d_1 := a_1;[128X[104X
    [4X[28X        f_1 := d_1;[128X[104X
    [4X[28X        g_1 := f_1;[128X[104X
    [4X[28X        return g_1;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    e_1 := c_1;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local y@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x < 0 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        Error( "error" )@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x = 1 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return true@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    y := 2@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return false@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrettyPrintSyntaxTree( tree );[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  0_type := "EXPR_DECLARATIVE_FUNC",[128X[104X
    [4X[28X  1_id := 2,[128X[104X
    [4X[28X  2_nams := [ "x", "y", "RETURN_VALUE" ],[128X[104X
    [4X[28X  3_narg := 1,[128X[104X
    [4X[28X  4_variadic := false,[128X[104X
    [4X[28X  5_bindings := rec([128X[104X
    [4X[28X      0_type := "FVAR_BINDING_SEQ",[128X[104X
    [4X[28X      1_names := [ "RETURN_VALUE", "y" ],[128X[104X
    [4X[28X      2_BINDING_RETURN_VALUE := rec([128X[104X
    [4X[28X          0_type := "EXPR_CASE",[128X[104X
    [4X[28X          1_branches := rec([128X[104X
    [4X[28X              0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X              0_length := 2,[128X[104X
    [4X[28X              1 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_EQ",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 2,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 1 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ) ),[128X[104X
    [4X[28X              2 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_FALSE" ) ) ) ),[128X[104X
    [4X[28X      3_BINDING_y := rec([128X[104X
    [4X[28X          0_type := "EXPR_INT",[128X[104X
    [4X[28X          1_value := 2 ) ) )[128X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := original_func_id;;[127X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQ := HomalgFieldOfRationals();;[127X[104X
    [4X[25Xgap>[125X [27Xvec := MatrixCategory( Q : enable_compilation := true );;[127X[104X
    [4X[25Xgap>[125X [27XV := VectorSpaceObject( 2, Q );;[127X[104X
    [4X[25Xgap>[125X [27Xalpha := ZeroMorphism( V, V );;[127X[104X
    [4X[25Xgap>[125X [27Xbeta := IdentityMorphism( V );;[127X[104X
    [4X[25Xgap>[125X [27XW := DirectSum( V, V );;[127X[104X
    [4X[25Xgap>[125X [27Xmorphism_matrix := [ [ alpha, beta ], [ beta, alpha ] ];;[127X[104X
    [4X[25Xgap>[125X [27X# compile the primitive installation of[127X[104X
    [4X[25X>[125X [27X# MorphismBetweenDirectSumsWithGivenDirectSums[127X[104X
    [4X[25X>[125X [27XDisplay([127X[104X
    [4X[25X>[125X [27X    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[3][1][127X[104X
    [4X[25X>[125X [27X);[127X[104X
    [4X[28Xfunction ( cat, S, diagram_S, morphism_matrix, diagram_T, T )[128X[104X
    [4X[28X    local underlying_matrix;[128X[104X
    [4X[28X    underlying_matrix := List( morphism_matrix, function ( row )[128X[104X
    [4X[28X            return List( row, UnderlyingMatrix );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    underlying_matrix := ListN( diagram_S, underlying_matrix, [128X[104X
    [4X[28X       function ( source, row )[128X[104X
    [4X[28X            return UnionOfColumns( homalg_field, Dimension( source ), row );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return [128X[104X
    [4X[28X     VectorSpaceMorphism( cat, S, UnionOfRows( homalg_field, Dimension( T ), [128X[104X
    [4X[28X         underlying_matrix ), T );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XMorphismBetweenDirectSumsWithGivenDirectSums([127X[104X
    [4X[25X>[125X [27X    vec,[127X[104X
    [4X[25X>[125X [27X    W,[127X[104X
    [4X[25X>[125X [27X    [ V, V ],[127X[104X
    [4X[25X>[125X [27X    morphism_matrix,[127X[104X
    [4X[25X>[125X [27X    [ V, V ],[127X[104X
    [4X[25X>[125X [27X    W[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XDisplay([127X[104X
    [4X[25X>[125X [27X    vec!.compiled_functions.MorphismBetweenDirectSumsWithGivenDirectSums[3][127X[104X
    [4X[25X>[125X [27X);[127X[104X
    [4X[28Xfunction ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1, cap_jit_deduplicated_expression_1_1;[128X[104X
    [4X[28X    cap_jit_deduplicated_expression_1_1 := UnderlyingRing( cat_1 );[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := cap_jit_deduplicated_expression_1_1;[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, S_1, T_1, UnderlyingMatrix, [128X[104X
    [4X[28X       UnionOfRows( cap_jit_deduplicated_expression_1_1, Dimension( T_1 ), [128X[104X
    [4X[28X         ListN( diagram_S_1, List( morphism_matrix_1, function ( row_2 )[128X[104X
    [4X[28X                  return List( row_2, UnderlyingMatrix );[128X[104X
    [4X[28X              end ), function ( source_2, row_2 )[128X[104X
    [4X[28X                return UnionOfColumns( cap_jit_hoisted_expression_1_1, [128X[104X
    [4X[28X                   Dimension( source_2 ), row_2 );[128X[104X
    [4X[28X            end ) ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# compile the default derivation of[127X[104X
    [4X[25X>[125X [27X# MorphismBetweenDirectSumsWithGivenDirectSums[127X[104X
    [4X[25X>[125X [27XDisplay([127X[104X
    [4X[25X>[125X [27X    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1][127X[104X
    [4X[25X>[125X [27X);[127X[104X
    [4X[28Xfunction ( cat, S, diagram_S, morphism_matrix, diagram_T, T )[128X[104X
    [4X[28X    local test_diagram_product, test_diagram_coproduct;[128X[104X
    [4X[28X    test_diagram_coproduct := ListN( diagram_S, morphism_matrix, [128X[104X
    [4X[28X       function ( source, row )[128X[104X
    [4X[28X            return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, [128X[104X
    [4X[28X               diagram_T, source, row, T );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, diagram_S, [128X[104X
    [4X[28X       T, test_diagram_coproduct, S );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction([127X[104X
    [4X[25X>[125X [27X    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1],[127X[104X
    [4X[25X>[125X [27X    [ vec, W, [ V, V ], morphism_matrix, [ V, V ], W  ][127X[104X
    [4X[25X>[125X [27X) );;[127X[104X
    [4X[28Xfunction ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1, cap_jit_deduplicated_expression_1_1;[128X[104X
    [4X[28X    cap_jit_deduplicated_expression_1_1 := UnderlyingRing( cat_1 );[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := cap_jit_deduplicated_expression_1_1;[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, S_1, T_1, UnderlyingMatrix, [128X[104X
    [4X[28X       UnionOfRows( cap_jit_deduplicated_expression_1_1, Dimension( T_1 ), [128X[104X
    [4X[28X         ListN( diagram_S_1, morphism_matrix_1, [128X[104X
    [4X[28X           function ( logic_new_func_x_2, logic_new_func_y_2 )[128X[104X
    [4X[28X                return UnionOfColumns( cap_jit_hoisted_expression_1_1, [128X[104X
    [4X[28X                   Dimension( logic_new_func_x_2 ), [128X[104X
    [4X[28X                   List( logic_new_func_y_2, function ( s_3 )[128X[104X
    [4X[28X                          return UnderlyingMatrix( s_3 );[128X[104X
    [4X[28X                      end ) );[128X[104X
    [4X[28X            end ) ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XKernelEmbedding( alpha );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( Last( vec!.compiled_functions.KernelEmbedding ) );[127X[104X
    [4X[28Xfunction ( cat_1, morphism_1 )[128X[104X
    [4X[28X    local cap_jit_morphism_attribute_1_1;[128X[104X
    [4X[28X    cap_jit_morphism_attribute_1_1 [128X[104X
    [4X[28X     := SyzygiesOfRows( UnderlyingMatrix( morphism_1 ) );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X             ), cat_1, Dimension, NrRows( cap_jit_morphism_attribute_1_1 ) ), [128X[104X
    [4X[28X       Source( morphism_1 ), UnderlyingMatrix, cap_jit_morphism_attribute_1_1 [128X[104X
    [4X[28X       );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27X# be careful not to use `MatrixCategory` because attributes are not supported[127X[104X
    [4X[25X>[125X [27Xcategory_constructor := field -> MATRIX_CATEGORY( field );;[127X[104X
    [4X[25Xgap>[125X [27Xgiven_arguments := [ QQ ];;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_category_name := "MatrixCategoryPrecompiled";;[127X[104X
    [4X[25Xgap>[125X [27Xpackage_name := "LinearAlgebraForCAP";;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Intersection([127X[104X
    [4X[25X>[125X [27X    ListInstalledOperationsOfCategory( category_constructor( QQ ) ),[127X[104X
    [4X[25X>[125X [27X    CAP_JIT_INTERNAL_SAFE_OPERATIONS[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27X# exclude some operations which currently do not yield nice results[127X[104X
    [4X[25X>[125X [27Xoperations := Filtered( operations,[127X[104X
    [4X[25X>[125X [27X                        o -> PositionSublist( o, "FiberProduct" ) = fail );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Filtered( operations,[127X[104X
    [4X[25X>[125X [27X                        o -> PositionSublist( o, "Pushout" ) = fail );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Filtered( operations,[127X[104X
    [4X[25X>[125X [27X                        o -> PositionSublist( o, "Image" ) = fail );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Filtered( operations,[127X[104X
    [4X[25X>[125X [27X                        o -> PositionSublist( o, "Coimage" ) = fail );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Filtered( operations,[127X[104X
    [4X[25X>[125X [27X                        o -> PositionSublist( o, "DirectProduct" ) = fail );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Filtered( operations,[127X[104X
    [4X[25X>[125X [27X                        o -> PositionSublist( o, "Coproduct" ) = fail );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Filtered( operations,[127X[104X
    [4X[25X>[125X [27X                        o -> PositionSublist( o, "TerminalObject" ) = fail );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Filtered( operations,[127X[104X
    [4X[25X>[125X [27X                        o -> PositionSublist( o, "InitialObject" ) = fail );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Difference( operations, [ "DirectSumCodiagonalDifference" ] );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Difference( operations, [ "DirectSumDiagonalDifference" ] );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Difference( operations, [ "HomologyObject" ] );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Difference( operations, [ "LiftOrFail", "ColiftOrFail" ] );;[127X[104X
    [4X[25Xgap>[125X [27X# IsEqualForMorphismsOnMor causes problems in GAP 4.11 (see GAP issue #4449)[127X[104X
    [4X[25X>[125X [27Xoperations := Difference( operations, [ "IsEqualForMorphismsOnMor" ] );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Difference( operations, [ "IsIdenticalToIdentityMorphism" ] );;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Difference( operations, [ "IsIdenticalToZeroMorphism" ] );;[127X[104X
    [4X[25Xgap>[125X [27X# IsZeroForMorphisms tries to resolve IsZero and IsZero has a new[127X[104X
    [4X[25X>[125X [27X# installation in GAP 4.12, so this causes slight differences in the output[127X[104X
    [4X[25X>[125X [27Xoperations := Difference( operations, [ "IsZeroForMorphisms" ] );;[127X[104X
    [4X[25Xgap>[125X [27XAdd( operations, "DirectSumFunctorialWithGivenDirectSums" );[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X    category_constructor,[127X[104X
    [4X[25X>[125X [27X    given_arguments,[127X[104X
    [4X[25X>[125X [27X    package_name,[127X[104X
    [4X[25X>[125X [27X    compiled_category_name :[127X[104X
    [4X[25X>[125X [27X    operations := operations[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XMatrixCategoryPrecompiled( QQ );[127X[104X
    [4X[28XCategory of matrices over Q[128X[104X
  [4X[32X[104X
  
  
  [1X3.2 [33X[0;0YTests[133X[101X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_DROP_NEXT_STATEMENT[127X[104X
    [4X[25X>[125X [27X    Display( 1 ); return 1; end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, [ ] ) );[127X[104X
    [4X[28Xfunction ( )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27Xcat := MatrixCategory( QQ );;[127X[104X
    [4X[25Xgap>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function( cat )[127X[104X
    [4X[25X>[125X [27X  local predicate, func, initial_value@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    predicate := { x, y } -> Dimension( x ) = 3 and Dimension( y ) = 2@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    func := x -> MatrixCategoryObject( cat, Dimension( x ) - 1 )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    initial_value := MatrixCategoryObject( cat, 10 )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return CapFixpoint( predicate, func, initial_value )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xfunc( cat );[127X[104X
    [4X[28X<A vector space object over Q of dimension 2>[128X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, [ cat ] ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Dimension, CapFixpoint( function ( x_2, y_2 )[128X[104X
    [4X[28X              return x_2 = 3 and y_2 = 2;[128X[104X
    [4X[28X          end, function ( x_2 )[128X[104X
    [4X[28X              return x_2 - 1;[128X[104X
    [4X[28X          end, 10 ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# Iterated (for morphisms)[127X[104X
    [4X[25X>[125X [27X# PreComposeList[127X[104X
    [4X[25X>[125X [27Xfunc := { cat, morphism_list } ->[127X[104X
    [4X[25X>[125X [27X    Iterated([127X[104X
    [4X[25X>[125X [27X        morphism_list,[127X[104X
    [4X[25X>[125X [27X        { alpha, beta } -> PreCompose( cat, alpha, beta )[127X[104X
    [4X[25X>[125X [27X    );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, [ cat ] ) );[127X[104X
    [4X[28Xfunction ( cat_1, morphism_list_1 )[128X[104X
    [4X[28X    local cap_jit_morphism_attribute_1_1;[128X[104X
    [4X[28X    cap_jit_morphism_attribute_1_1 [128X[104X
    [4X[28X     := Iterated( List( morphism_list_1, UnderlyingMatrix ), [128X[104X
    [4X[28X       function ( alpha_2, beta_2 )[128X[104X
    [4X[28X            return alpha_2 * beta_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X             ), cat_1, Dimension, NrRows( cap_jit_morphism_attribute_1_1 ) ), [128X[104X
    [4X[28X       ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X             ), cat_1, Dimension, NrColumns( cap_jit_morphism_attribute_1_1 ) [128X[104X
    [4X[28X         ), UnderlyingMatrix, cap_jit_morphism_attribute_1_1 );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# Iterated with list[127X[104X
    [4X[25X>[125X [27Xfunc := { cat, alpha, beta, gamma } ->[127X[104X
    [4X[25X>[125X [27X    Iterated([127X[104X
    [4X[25X>[125X [27X        [ alpha, beta, gamma ],[127X[104X
    [4X[25X>[125X [27X        { alpha, beta } -> PreCompose( cat, alpha, beta )[127X[104X
    [4X[25X>[125X [27X    );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, [ cat ] ) );[127X[104X
    [4X[28Xfunction ( cat_1, alpha_1, beta_1, gamma_1 )[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Source( alpha_1 ), Range( gamma_1 ), UnderlyingMatrix, [128X[104X
    [4X[28X       UnderlyingMatrix( alpha_1 ) * UnderlyingMatrix( beta_1 ) [128X[104X
    [4X[28X        * UnderlyingMatrix( gamma_1 ) );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQ := HomalgFieldOfRationals();;[127X[104X
    [4X[25Xgap>[125X [27Xrows := MatrixCategory( Q );;[127X[104X
    [4X[25Xgap>[125X [27XMyKernelLift := function( cat, mor, test_mor )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL[127X[104X
    [4X[25X>[125X [27X    return LiftOrFail( cat, test_mor, KernelEmbedding( cat, mor ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27XV := VectorSpaceObject( 2, Q );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := CapJitCompiledFunction([127X[104X
    [4X[25X>[125X [27X    MyKernelLift,[127X[104X
    [4X[25X>[125X [27X    [ rows, ZeroMorphism( V, V ), IdentityMorphism( V ) ][127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( cat_1, mor_1, test_mor_1 )[128X[104X
    [4X[28X    local cap_jit_morphism_attribute_1_1;[128X[104X
    [4X[28X    cap_jit_morphism_attribute_1_1 [128X[104X
    [4X[28X     := RightDivide( UnderlyingMatrix( test_mor_1 ), [128X[104X
    [4X[28X       SyzygiesOfRows( UnderlyingMatrix( mor_1 ) ) );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Source( test_mor_1 ), [128X[104X
    [4X[28X       ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X             ), cat_1, Dimension, NrColumns( cap_jit_morphism_attribute_1_1 ) )[128X[104X
    [4X[28X        , UnderlyingMatrix, cap_jit_morphism_attribute_1_1 );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc1 := function( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    if x = 1 then return fail; fi; return 1; end;;[127X[104X
    [4X[25Xgap>[125X [27Xfunc2 := function( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    if x = 1 then return fail; else return 1; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xcall_func1 := function( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL[127X[104X
    [4X[25X>[125X [27X    return func1( x ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xcall_func2 := function( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL[127X[104X
    [4X[25X>[125X [27X    return func2( x ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( call_func1, [ 2 ] ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( call_func2, [ 2 ] ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# duplicate code inside a function[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> (y + (x + 1)) + (y + (x + 1)) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            local cap_jit_deduplicated_expression_1_2;[128X[104X
    [4X[28X            cap_jit_deduplicated_expression_1_2 := y_2 + (x_1 + 1);[128X[104X
    [4X[28X            return cap_jit_deduplicated_expression_1_2 [128X[104X
    [4X[28X              + cap_jit_deduplicated_expression_1_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# duplicate code inside duplicate code[127X[104X
    [4X[25X>[125X [27Xfunc := function( x, y )[127X[104X
    [4X[25X>[125X [27X    return (y + (x + 1) + (x + 1)) + (y + (x + 1) + (x + 1)); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1, y_1 )[128X[104X
    [4X[28X    local cap_jit_deduplicated_expression_1_1, [128X[104X
    [4X[28X    cap_jit_deduplicated_expression_2_1;[128X[104X
    [4X[28X    cap_jit_deduplicated_expression_2_1 := x_1 + 1;[128X[104X
    [4X[28X    cap_jit_deduplicated_expression_1_1 [128X[104X
    [4X[28X     := y_1 + cap_jit_deduplicated_expression_2_1 [128X[104X
    [4X[28X      + cap_jit_deduplicated_expression_2_1;[128X[104X
    [4X[28X    return cap_jit_deduplicated_expression_1_1 [128X[104X
    [4X[28X      + cap_jit_deduplicated_expression_1_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# don't deduplicate code accross functions[127X[104X
    [4X[25X>[125X [27Xfunc := function( )[127X[104X
    [4X[25X>[125X [27X    return [ [ x -> (x + 1) + 2 ], [ x -> (x + 1) + 3 ] ]; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return [ [ function ( x_2 )[128X[104X
    [4X[28X                  return x_2 + 1 + 2;[128X[104X
    [4X[28X              end ], [ function ( x_2 )[128X[104X
    [4X[28X                  return x_2 + 1 + 3;[128X[104X
    [4X[28X              end ] ];[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# duplicate code inside duplicate code at different function levels[127X[104X
    [4X[25X>[125X [27Xfunc := {} ->[127X[104X
    [4X[25X>[125X [27X    y -> [ [ y, x -> (x + 1) + (x + 1) ], [ y, x -> (x + 1) + (x + 1) ] ];;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return function ( y_2 )[128X[104X
    [4X[28X          local cap_jit_deduplicated_expression_1_2;[128X[104X
    [4X[28X          cap_jit_deduplicated_expression_1_2 := [ y_2, function ( x_3 )[128X[104X
    [4X[28X                    local cap_jit_deduplicated_expression_1_3;[128X[104X
    [4X[28X                    cap_jit_deduplicated_expression_1_3 := x_3 + 1;[128X[104X
    [4X[28X                    return cap_jit_deduplicated_expression_1_3 [128X[104X
    [4X[28X                      + cap_jit_deduplicated_expression_1_3;[128X[104X
    [4X[28X                end ];[128X[104X
    [4X[28X          return [128X[104X
    [4X[28X           [ cap_jit_deduplicated_expression_1_2, [128X[104X
    [4X[28X              cap_jit_deduplicated_expression_1_2 ];[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# deduplication after hoisting in duplicated code[127X[104X
    [4X[25X>[125X [27Xfunc := { f, L } ->[127X[104X
    [4X[25X>[125X [27X    [ f( y -> List( L, l -> y + y ) ), f( y -> List( L, l -> y + y ) ) ];;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( f_1, L_1 )[128X[104X
    [4X[28X    local cap_jit_deduplicated_expression_1_1;[128X[104X
    [4X[28X    cap_jit_deduplicated_expression_1_1 := f_1( function ( y_2 )[128X[104X
    [4X[28X            local cap_jit_hoisted_expression_1_2;[128X[104X
    [4X[28X            cap_jit_hoisted_expression_1_2 := y_2 + y_2;[128X[104X
    [4X[28X            return List( L_1, function ( l_3 )[128X[104X
    [4X[28X                    return cap_jit_hoisted_expression_1_2;[128X[104X
    [4X[28X                end );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return [128X[104X
    [4X[28X     [ cap_jit_deduplicated_expression_1_1, [128X[104X
    [4X[28X        cap_jit_deduplicated_expression_1_1 ];[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# make sure that ignoring paths in replaced paths works as expected[127X[104X
    [4X[25X>[125X [27Xfunc := {} ->[127X[104X
    [4X[25X>[125X [27X    [ [ [ [ 1 ] ], [ [ 1 ] ] ], [ [ [ 1 ] ], [ [ 1 ] ] ] ];;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local cap_jit_deduplicated_expression_1_1, [128X[104X
    [4X[28X    cap_jit_deduplicated_expression_2_1;[128X[104X
    [4X[28X    cap_jit_deduplicated_expression_2_1 := [ [ 1 ] ];[128X[104X
    [4X[28X    cap_jit_deduplicated_expression_1_1 [128X[104X
    [4X[28X     := [ cap_jit_deduplicated_expression_2_1, [128X[104X
    [4X[28X        cap_jit_deduplicated_expression_2_1 ];[128X[104X
    [4X[28X    return [128X[104X
    [4X[28X     [ cap_jit_deduplicated_expression_1_1, [128X[104X
    [4X[28X        cap_jit_deduplicated_expression_1_1 ];[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local inner_func@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    inner_func := function( y )[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        if y < 1 then[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 2@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        elif y > 10 then[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 3@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        else[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 4@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        fi@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    end@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x < 1 or x > 10 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return 0@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    elif x = 3 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return 1@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    else[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return inner_func( x )@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := CapJitCompiledFunction( func, [ ] );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    if x_1 < 1 or x_1 > 10 then[128X[104X
    [4X[28X        return 0;[128X[104X
    [4X[28X    elif x_1 = 3 then[128X[104X
    [4X[28X        return 1;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return 4;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# check that CapJitDroppedUnusedBindings is idempotent[127X[104X
    [4X[25X>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  local val1, val2; val1 := 1; val2 := val1; return 1; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDroppedUnusedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitDroppedUnusedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hoisting with deduplication[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> (y + (x + 1)) + (y + (x + 1)) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := x_1 + 1;[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return y_2 + cap_jit_hoisted_expression_1_1 [128X[104X
    [4X[28X              + (y_2 + cap_jit_hoisted_expression_1_1);[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hoisting of whole functions[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> y + List( [ 1 .. 9 ], z -> x + z ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := List( [ 1 .. 9 ], function ( z_2 )[128X[104X
    [4X[28X            return x_1 + z_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return y_2 + cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# no hoisting of constants[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> y + 1 ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return y_2 + 1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hoisting of returned expressions[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> x + 1 ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := x_1 + 1;[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hoisting of assigned expressions[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], function( y )[127X[104X
    [4X[25X>[125X [27X        local z; z := x + 1; return z; end ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := x_1 + 1;[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            local z_2;[128X[104X
    [4X[28X            z_2 := cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X            return z_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hosted expressions inside hosted expressions[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], function( y )[127X[104X
    [4X[25X>[125X [27X        return List( [ 1 .. 9 ], z -> z + (1 + 1) ); end ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1, cap_jit_hoisted_expression_2_1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := 1 + 1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_2_1 := List( [ 1 .. 9 ], function ( z_2 )[128X[104X
    [4X[28X            return z_2 + cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return cap_jit_hoisted_expression_2_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# deduplication of more complex trees, e.g. functions[127X[104X
    [4X[25X>[125X [27Xfunc := function( list )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], function( y )[127X[104X
    [4X[25X>[125X [27X        return (y + Sum( list, a -> a )) + Sum( list, a -> a ); end ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( list_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := Sum( list_1, function ( a_2 )[128X[104X
    [4X[28X            return a_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return y_2 + cap_jit_hoisted_expression_1_1 [128X[104X
    [4X[28X              + cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hosting of expressions in lists, e.g. function call arguments[127X[104X
    [4X[25X>[125X [27Xfunc := function( x, func )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> func( x + 1, x + 1, y ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1, func_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := x_1 + 1;[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return func_1( cap_jit_hoisted_expression_1_1, [128X[104X
    [4X[28X               cap_jit_hoisted_expression_1_1, y_2 );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# restrict hoisting to if/else branches (where possible)[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    if x < 0 then return 0; else return y -> [ x + 1, z -> y + 1 ]; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        return 0;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        cap_jit_hoisted_expression_1_1 := x_1 + 1;[128X[104X
    [4X[28X        return function ( y_2 )[128X[104X
    [4X[28X              local cap_jit_hoisted_expression_1_2;[128X[104X
    [4X[28X              cap_jit_hoisted_expression_1_2 := y_2 + 1;[128X[104X
    [4X[28X              return [ cap_jit_hoisted_expression_1_1, function ( z_3 )[128X[104X
    [4X[28X                        return cap_jit_hoisted_expression_1_2;[128X[104X
    [4X[28X                    end ];[128X[104X
    [4X[28X          end;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    if x < 0 then return y -> [ x + 1, z -> y + 1 ]; else return 0; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        cap_jit_hoisted_expression_1_1 := x_1 + 1;[128X[104X
    [4X[28X        return function ( y_2 )[128X[104X
    [4X[28X              local cap_jit_hoisted_expression_1_2;[128X[104X
    [4X[28X              cap_jit_hoisted_expression_1_2 := y_2 + 1;[128X[104X
    [4X[28X              return [ cap_jit_hoisted_expression_1_1, function ( z_3 )[128X[104X
    [4X[28X                        return cap_jit_hoisted_expression_1_2;[128X[104X
    [4X[28X                    end ];[128X[104X
    [4X[28X          end;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return 0;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X  if x < 0 then return y -> [ y, x+1 ]; else return y -> [ y, x+1 ]; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local cap_jit_hoisted_expression_1_1;[128X[104X
    [4X[28X    cap_jit_hoisted_expression_1_1 := x_1 + 1;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        return function ( y_2 )[128X[104X
    [4X[28X              return [ y_2, cap_jit_hoisted_expression_1_1 ];[128X[104X
    [4X[28X          end;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return function ( y_2 )[128X[104X
    [4X[28X              return [ y_2, cap_jit_hoisted_expression_1_1 ];[128X[104X
    [4X[28X          end;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# check that CapJitInlinedBindings is idempotent[127X[104X
    [4X[25X>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  local val1, val2; val1 := 1; val2 := val1; return val2; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitInlinedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local val1_1, val2_1;[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28X    val1_1 := 1;[128X[104X
    [4X[28X    val2_1 := 1;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitInlinedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local val1_1, val2_1;[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28X    val1_1 := 1;[128X[104X
    [4X[28X    val2_1 := 1;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# make tests deterministic[127X[104X
    [4X[25X>[125X [27Xoriginal_func_id := CAP_JIT_INTERNAL_FUNCTION_ID;;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := 1;;[127X[104X
    [4X[25Xgap>[125X [27X# check that CapJitInlinedFunctionCalls is idempotent[127X[104X
    [4X[25X>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return (function ( )[127X[104X
    [4X[25X>[125X [27X        return (function ( )[127X[104X
    [4X[25X>[125X [27X            return 1; end)( ); end)( ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitInlinedFunctionCalls( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local inline_2_RETURN_VALUE_1, inline_2_inline_3_RETURN_VALUE_1;[128X[104X
    [4X[28X    inline_2_inline_3_RETURN_VALUE_1 := 1;[128X[104X
    [4X[28X    inline_2_RETURN_VALUE_1 := inline_2_inline_3_RETURN_VALUE_1;[128X[104X
    [4X[28X    return inline_2_RETURN_VALUE_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitInlinedFunctionCalls( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local inline_2_RETURN_VALUE_1, inline_2_inline_3_RETURN_VALUE_1;[128X[104X
    [4X[28X    inline_2_inline_3_RETURN_VALUE_1 := 1;[128X[104X
    [4X[28X    inline_2_RETURN_VALUE_1 := inline_2_inline_3_RETURN_VALUE_1;[128X[104X
    [4X[28X    return inline_2_RETURN_VALUE_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := original_func_id;;[127X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# make tests deterministic[127X[104X
    [4X[25X>[125X [27X# we want to apply logic templates, which contain functions with existing IDs,[127X[104X
    [4X[25X>[125X [27X# so we really have to use new IDs[127X[104X
    [4X[25X>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID < 10^6;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xoriginal_func_id := CAP_JIT_INTERNAL_FUNCTION_ID;;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := 10^6;;[127X[104X
    [4X[25Xgap>[125X [27X# test that `CAP_JIT_NOT_RESOLVABLE` does not cause errors when comparing[127X[104X
    [4X[25X>[125X [27X# syntax trees[127X[104X
    [4X[25X>[125X [27XDeclareOperation( "MyNonResolvableOperation", [ ] );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := { } -> MyNonResolvableOperation( );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree2 := StructuralCopy( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xtree2.bindings.BINDING_RETURN_VALUE.funcref.CAP_JIT_NOT_RESOLVABLE := true;;[127X[104X
    [4X[25Xgap>[125X [27XCapJitIsEqualForEnhancedSyntaxTrees( tree, tree2 );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# test that `CAP_JIT_IGNORE_OPERATION` does not cause errors when comparing[127X[104X
    [4X[25X>[125X [27X# syntax trees[127X[104X
    [4X[25X>[125X [27Xfunc := function ( L1 )[127X[104X
    [4X[25X>[125X [27X    return [[127X[104X
    [4X[25X>[125X [27X        List( List( L1, x -> x ), x -> Size( x ) ),[127X[104X
    [4X[25X>[125X [27X        List( List( L1, x -> x ), Size )[127X[104X
    [4X[25X>[125X [27X    ]; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitResolvedOperations( tree, [ ] );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree, [ ] );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitInlinedArguments( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitInlinedFunctionCalls( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitInlinedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDroppedUnusedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrettyPrintSyntaxTree( tree );[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  0_type := "EXPR_DECLARATIVE_FUNC",[128X[104X
    [4X[28X  1_id := 1000001,[128X[104X
    [4X[28X  2_nams := [ "L1", "RETURN_VALUE" ],[128X[104X
    [4X[28X  3_narg := 1,[128X[104X
    [4X[28X  4_variadic := false,[128X[104X
    [4X[28X  5_bindings := rec([128X[104X
    [4X[28X      0_type := "FVAR_BINDING_SEQ",[128X[104X
    [4X[28X      1_names := [ "RETURN_VALUE" ],[128X[104X
    [4X[28X      2_BINDING_RETURN_VALUE := rec([128X[104X
    [4X[28X          0_type := "EXPR_LIST",[128X[104X
    [4X[28X          1_list := rec([128X[104X
    [4X[28X              0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X              0_length := 2,[128X[104X
    [4X[28X              1 := rec([128X[104X
    [4X[28X                  0_type := "EXPR_FUNCCALL",[128X[104X
    [4X[28X                  1_funcref := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_GVAR",[128X[104X
    [4X[28X                      1_gvar := "List" ),[128X[104X
    [4X[28X                  2_args := rec([128X[104X
    [4X[28X                      0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X                      0_length := 2,[128X[104X
    [4X[28X                      1 := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1000001,[128X[104X
    [4X[28X                          2_name := "L1" ),[128X[104X
    [4X[28X                      2 := rec([128X[104X
    [4X[28X                          0_type := "EXPR_DECLARATIVE_FUNC",[128X[104X
    [4X[28X                          1_id := 1000005,[128X[104X
    [4X[28X                          2_nams := [ "logic_new_func_x", "RETURN_VALUE" ],[128X[104X
    [4X[28X                          3_narg := 1,[128X[104X
    [4X[28X                          4_variadic := false,[128X[104X
    [4X[28X                          5_bindings := rec([128X[104X
    [4X[28X                              0_type := "FVAR_BINDING_SEQ",[128X[104X
    [4X[28X                              1_names := [ "RETURN_VALUE" ],[128X[104X
    [4X[28X                              2_BINDING_RETURN_VALUE := rec([128X[104X
    [4X[28X                                  0_type := "EXPR_FUNCCALL",[128X[104X
    [4X[28X                                  1_CAP_JIT_IGNORE_OPERATION := true,[128X[104X
    [4X[28X                                  2_funcref := rec([128X[104X
    [4X[28X                                      0_type := "EXPR_REF_GVAR",[128X[104X
    [4X[28X                                      1_gvar := "Size" ),[128X[104X
    [4X[28X                                  3_args := rec([128X[104X
    [4X[28X                                      0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X                                      0_length := 1,[128X[104X
    [4X[28X                                      1 := rec([128X[104X
    [4X[28X                                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                                          1_func_id := 1000005,[128X[104X
    [4X[28X                                          2_name := "logic_new_func_x" ) ) ) [128X[104X
    [4X[28X                             ) ) ) ),[128X[104X
    [4X[28X              2 := rec([128X[104X
    [4X[28X                  0_type := "EXPR_FUNCCALL",[128X[104X
    [4X[28X                  1_funcref := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_GVAR",[128X[104X
    [4X[28X                      1_gvar := "List" ),[128X[104X
    [4X[28X                  2_args := rec([128X[104X
    [4X[28X                      0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X                      0_length := 2,[128X[104X
    [4X[28X                      1 := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1000001,[128X[104X
    [4X[28X                          2_name := "L1" ),[128X[104X
    [4X[28X                      2 := rec([128X[104X
    [4X[28X                          0_type := "EXPR_DECLARATIVE_FUNC",[128X[104X
    [4X[28X                          1_id := 1000008,[128X[104X
    [4X[28X                          2_nams := [ "logic_new_func_x", "RETURN_VALUE" ],[128X[104X
    [4X[28X                          3_narg := 1,[128X[104X
    [4X[28X                          4_variadic := false,[128X[104X
    [4X[28X                          5_bindings := rec([128X[104X
    [4X[28X                              0_type := "FVAR_BINDING_SEQ",[128X[104X
    [4X[28X                              1_names := [ "RETURN_VALUE" ],[128X[104X
    [4X[28X                              2_BINDING_RETURN_VALUE := rec([128X[104X
    [4X[28X                                  0_type := "EXPR_FUNCCALL",[128X[104X
    [4X[28X                                  1_funcref := rec([128X[104X
    [4X[28X                                      0_type := "EXPR_REF_GVAR",[128X[104X
    [4X[28X                                      1_gvar := "Size" ),[128X[104X
    [4X[28X                                  2_args := rec([128X[104X
    [4X[28X                                      0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X                                      0_length := 1,[128X[104X
    [4X[28X                                      1 := rec([128X[104X
    [4X[28X                                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                                          1_func_id := 1000008,[128X[104X
    [4X[28X                                          2_name := "logic_new_func_x" ) ) ) [128X[104X
    [4X[28X                             ) ) ) ) ) ) ) )[128X[104X
    [4X[25Xgap>[125X [27XT1 := tree.bindings.BINDING_RETURN_VALUE.list.1;;[127X[104X
    [4X[25Xgap>[125X [27XT2 := tree.bindings.BINDING_RETURN_VALUE.list.2;;[127X[104X
    [4X[25Xgap>[125X [27XIsBound( T1.args.2.bindings.BINDING_RETURN_VALUE.CAP_JIT_IGNORE_OPERATION );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XIsBound( T2.args.2.bindings.BINDING_RETURN_VALUE.CAP_JIT_IGNORE_OPERATION );[127X[104X
    [4X[28Xfalse[128X[104X
    [4X[25Xgap>[125X [27XCapJitIsEqualForEnhancedSyntaxTrees( T2, T1 );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := original_func_id;;[127X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xfunc := { cat, matrix } -> [[127X[104X
    [4X[25X>[125X [27X    VectorSpaceMorphism( cat, ObjectConstructor( cat, NrRows( matrix ) ),[127X[104X
    [4X[25X>[125X [27X        matrix, ObjectConstructor( cat, NrCols( matrix ) ) ),[127X[104X
    [4X[25X>[125X [27X    VectorSpaceMorphism( cat, ObjectConstructor( cat, NrRows( matrix ) ),[127X[104X
    [4X[25X>[125X [27X        matrix, ObjectConstructor( cat, NrCols( matrix ) ) ),[127X[104X
    [4X[25X>[125X [27X];;[127X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27Xcat := MatrixCategory( QQ );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, [ cat ] ) );[127X[104X
    [4X[28Xfunction ( cat_1, matrix_1 )[128X[104X
    [4X[28X    local cap_jit_morphism_attribute_1_1, cap_jit_morphism_attribute_2_1;[128X[104X
    [4X[28X    cap_jit_morphism_attribute_1_1 := matrix_1;[128X[104X
    [4X[28X    cap_jit_morphism_attribute_2_1 := matrix_1;[128X[104X
    [4X[28X    return [ ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X               ), cat_1, ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X                 ), cat_1, Dimension, NrRows( cap_jit_morphism_attribute_1_1 [128X[104X
    [4X[28X               ) ), ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X                 ), cat_1, Dimension, [128X[104X
    [4X[28X             NrColumns( cap_jit_morphism_attribute_1_1 ) ), UnderlyingMatrix, [128X[104X
    [4X[28X           cap_jit_morphism_attribute_1_1 ), [128X[104X
    [4X[28X        ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X               ), cat_1, ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X                 ), cat_1, Dimension, NrRows( cap_jit_morphism_attribute_2_1 [128X[104X
    [4X[28X               ) ), ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X                 ), cat_1, Dimension, [128X[104X
    [4X[28X             NrColumns( cap_jit_morphism_attribute_2_1 ) ), UnderlyingMatrix, [128X[104X
    [4X[28X           cap_jit_morphism_attribute_2_1 ) ];[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XMY_ID_FUNC := x -> x;;[127X[104X
    [4X[25Xgap>[125X [27Xfunc1 := function( x )[127X[104X
    [4X[25X>[125X [27X    if x = 1 then return 1; else return 2; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree1 := ENHANCED_SYNTAX_TREE( func1 );;[127X[104X
    [4X[25Xgap>[125X [27Xtree1.bindings.BINDING_RETURN_VALUE.type = "EXPR_CASE";[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xcoded_func1 := ENHANCED_SYNTAX_TREE_CODE( tree1 );;[127X[104X
    [4X[25Xgap>[125X [27XString( func1 ) = ReplacedString( String( coded_func1 ), "_1", "" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := rec([127X[104X
    [4X[25X>[125X [27X    type := "EXPR_DECLARATIVE_FUNC",[127X[104X
    [4X[25X>[125X [27X    id := 1,[127X[104X
    [4X[25X>[125X [27X    nams := [ "RETURN_VALUE" ],[127X[104X
    [4X[25X>[125X [27X    narg := 0,[127X[104X
    [4X[25X>[125X [27X    nloc := 1,[127X[104X
    [4X[25X>[125X [27X    variadic := false,[127X[104X
    [4X[25X>[125X [27X    bindings := rec([127X[104X
    [4X[25X>[125X [27X        type := "FVAR_BINDING_SEQ",[127X[104X
    [4X[25X>[125X [27X        length := 1,[127X[104X
    [4X[25X>[125X [27X        names := [ "RETURN_VALUE" ],[127X[104X
    [4X[25X>[125X [27X        BINDING_RETURN_VALUE := rec([127X[104X
    [4X[25X>[125X [27X            type := "EXPR_FUNCCALL",[127X[104X
    [4X[25X>[125X [27X            funcref := rec([127X[104X
    [4X[25X>[125X [27X                type := "EXPR_REF_GVAR",[127X[104X
    [4X[25X>[125X [27X                gvar := "MY_ID_FUNC",[127X[104X
    [4X[25X>[125X [27X            ),[127X[104X
    [4X[25X>[125X [27X            args := AsSyntaxTreeList( [[127X[104X
    [4X[25X>[125X [27X                rec([127X[104X
    [4X[25X>[125X [27X                    type := "EXPR_CASE",[127X[104X
    [4X[25X>[125X [27X                    branches := AsSyntaxTreeList( [[127X[104X
    [4X[25X>[125X [27X                        rec([127X[104X
    [4X[25X>[125X [27X                            type := "CASE_BRANCH",[127X[104X
    [4X[25X>[125X [27X                            condition := rec([127X[104X
    [4X[25X>[125X [27X                                type := "EXPR_FALSE",[127X[104X
    [4X[25X>[125X [27X                            ),[127X[104X
    [4X[25X>[125X [27X                            value := rec([127X[104X
    [4X[25X>[125X [27X                                type := "EXPR_INT",[127X[104X
    [4X[25X>[125X [27X                                value := 1,[127X[104X
    [4X[25X>[125X [27X                            ),[127X[104X
    [4X[25X>[125X [27X                        ),[127X[104X
    [4X[25X>[125X [27X                        rec([127X[104X
    [4X[25X>[125X [27X                            type := "CASE_BRANCH",[127X[104X
    [4X[25X>[125X [27X                            condition := rec([127X[104X
    [4X[25X>[125X [27X                                type := "EXPR_TRUE",[127X[104X
    [4X[25X>[125X [27X                            ),[127X[104X
    [4X[25X>[125X [27X                            value := rec([127X[104X
    [4X[25X>[125X [27X                                type := "EXPR_INT",[127X[104X
    [4X[25X>[125X [27X                                value := 2,[127X[104X
    [4X[25X>[125X [27X                            ),[127X[104X
    [4X[25X>[125X [27X                        ),[127X[104X
    [4X[25X>[125X [27X                    ] ),[127X[104X
    [4X[25X>[125X [27X                ),[127X[104X
    [4X[25X>[125X [27X            ] ),[127X[104X
    [4X[25X>[125X [27X        ),[127X[104X
    [4X[25X>[125X [27X    ),[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xcoded_func2 := ENHANCED_SYNTAX_TREE_CODE( tree2 );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( coded_func2 );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return MY_ID_FUNC( function (  )[128X[104X
    [4X[28X              if false then[128X[104X
    [4X[28X                  return 1;[128X[104X
    [4X[28X              else[128X[104X
    [4X[28X                  return 2;[128X[104X
    [4X[28X              fi;[128X[104X
    [4X[28X              return;[128X[104X
    [4X[28X          end(  ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xcoded_func2();[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc3 := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local inner_func@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    inner_func := function( )[127X[104X
    [4X[25X>[125X [27X      local y@[127X[104X
    [4X[25X>[125X [27X        if x then[127X[104X
    [4X[25X>[125X [27X            return 1@[127X[104X
    [4X[25X>[125X [27X        else[127X[104X
    [4X[25X>[125X [27X            y := 2@[127X[104X
    [4X[25X>[125X [27X            return y@[127X[104X
    [4X[25X>[125X [27X        fi@[127X[104X
    [4X[25X>[125X [27X    end@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return MY_ID_FUNC( inner_func( ) )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func3 := CapJitCompiledFunction( func3, [ true ] );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func3 );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    if x_1 then[128X[104X
    [4X[28X        return MY_ID_FUNC( 1 );[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return MY_ID_FUNC( 2 );[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc4 := function( x )[127X[104X
    [4X[25X>[125X [27X  local y; if x then return 1; else return 1; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func4 := CapJitCompiledFunction( func4, [ true ] );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func4 );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XKeyDependentOperation( "MyKeyDependentOperation",[127X[104X
    [4X[25X>[125X [27X                       IsGroup, IsInt, ReturnTrue );;[127X[104X
    [4X[25Xgap>[125X [27XInstallMethod( MyKeyDependentOperationOp,[127X[104X
    [4X[25X>[125X [27X    [ IsGroup, IsInt ],[127X[104X
    [4X[25X>[125X [27X    function( G, int )[127X[104X
    [4X[25X>[125X [27X        #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X        return int; end );;[127X[104X
    [4X[25Xgap>[125X [27XG := SymmetricGroup(3);;[127X[104X
    [4X[25Xgap>[125X [27XMyKeyDependentOperation( G, 2 ) = 2;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XMyFunction := G -> MyKeyDependentOperation( G, 2 );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := CapJitCompiledFunction( MyFunction, [ G ] );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( G_1 )[128X[104X
    [4X[28X    return 2;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xapplied_logic_template_to_func :=[127X[104X
    [4X[25X>[125X [27X    { func, template, jit_args } ->[127X[104X
    [4X[25X>[125X [27X        ENHANCED_SYNTAX_TREE_CODE([127X[104X
    [4X[25X>[125X [27X            CAP_JIT_INTERNAL_APPLIED_LOGIC_TEMPLATE([127X[104X
    [4X[25X>[125X [27X                ENHANCED_SYNTAX_TREE( func ),[127X[104X
    [4X[25X>[125X [27X                template,[127X[104X
    [4X[25X>[125X [27X                jit_args[127X[104X
    [4X[25X>[125X [27X            )[127X[104X
    [4X[25X>[125X [27X        );;[127X[104X
    [4X[25Xgap>[125X [27X# some general example[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "variable" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "x -> x + variable + x - x",[127X[104X
    [4X[25X>[125X [27X    dst_template := "x -> x + variable + 0",[127X[104X
    [4X[25X>[125X [27X    returns_value := true,[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( a )[127X[104X
    [4X[25X>[125X [27X    return b -> b + ( 2 * b + a ) + b - b; end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( a_1 )[128X[104X
    [4X[28X    return function ( b_2 )[128X[104X
    [4X[28X          return b_2 + (2 * b_2 + a_1) + 0;[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# general example not returning a value[127X[104X
    [4X[25X>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xtemplate := EvalString( ReplacedString( """rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "variable" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "return x -> x + variable + x - x@",[127X[104X
    [4X[25X>[125X [27X    dst_template := "return x -> x + variable + 0@",[127X[104X
    [4X[25X>[125X [27X    returns_value := false,[127X[104X
    [4X[25X>[125X [27X)""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( a_1 )[128X[104X
    [4X[28X    return function ( b_2 )[128X[104X
    [4X[28X          return b_2 + (2 * b_2 + a_1) + 0;[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# example testing needed_packages[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "name" ],[127X[104X
    [4X[25X>[125X [27X    variable_filters := [ "THIS_SHOULD_NOT_BE_PARSED" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "THIS_SHOULD_NOT_BE_PARSED_TOO",[127X[104X
    [4X[25X>[125X [27X    dst_template := "THIS_SHOULD_NOT_BE_PARSED_EITHER",[127X[104X
    [4X[25X>[125X [27X    returns_value := true,[127X[104X
    [4X[25X>[125X [27X    needed_packages := [ [ "NON_EXISTING_PACKAGE", ">= 9999" ] ],[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( x -> x, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return x_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that functions in variables can match[127X[104X
    [4X[25X>[125X [27X# and test jit_args (strings and filters)[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "L1", "L2", "func" ],[127X[104X
    [4X[25X>[125X [27X    variable_filters := [ "IsList", IsList, IsFunction ],[127X[104X
    [4X[25X>[125X [27X    src_template := "Concatenation( List( L1, func ), List( L2, func ) )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "List( Concatenation( L1, L2 ), func )",[127X[104X
    [4X[25X>[125X [27X    returns_value := true,[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( L1, L2 )[127X[104X
    [4X[25X>[125X [27X    return Concatenation( List( L1, x -> x ), List( L2, x -> x ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ [ ], [ ] ] ) );[127X[104X
    [4X[28Xfunction ( L1_1, L2_1 )[128X[104X
    [4X[28X    return List( Concatenation( L1_1, L2_1 ), function ( x_2 )[128X[104X
    [4X[28X            return x_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that template is not executed if variable filters but not enough[127X[104X
    [4X[25X>[125X [27X# jit_args are given[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "L1", "L2", "func" ],[127X[104X
    [4X[25X>[125X [27X    variable_filters := [ "IsList", IsList, IsFunction ],[127X[104X
    [4X[25X>[125X [27X    src_template := "Concatenation( List( L1, func ), List( L2, func ) )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "List( Concatenation( L1, L2 ), func )",[127X[104X
    [4X[25X>[125X [27X    returns_value := true,[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( L1, L2 )[127X[104X
    [4X[25X>[125X [27X    return Concatenation( List( L1, x -> x ), List( L2, x -> x ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( L1_1, L2_1 )[128X[104X
    [4X[28X    return Concatenation( List( L1_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end ), List( L2_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that template is only applied if filters match[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "value" ],[127X[104X
    [4X[25X>[125X [27X    variable_filters := [ IsInt ],[127X[104X
    [4X[25X>[125X [27X    src_template := "Sum( [ value ] )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "value",[127X[104X
    [4X[25X>[125X [27X    returns_value := true,[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := { x } -> Sum( [ x ] );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ 1/2 ] ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return Sum( [ x_1 ] );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ 1 ] ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return x_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that template is skipped if values cannot be determined from jit_args[127X[104X
    [4X[25X>[125X [27Xtemplate := EvalString( ReplacedString( """rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "value1", "value2" ],[127X[104X
    [4X[25X>[125X [27X    variable_filters := [ IsInt, IsObject ],[127X[104X
    [4X[25X>[125X [27X    src_template := "if 1 <> 1 then return value1@ else return value2@ fi@",[127X[104X
    [4X[25X>[125X [27X    dst_template := "return value2@",[127X[104X
    [4X[25X>[125X [27X    returns_value := false,[127X[104X
    [4X[25X>[125X [27X)""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X    if 1 <> 1 then return 1; else return 1; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    if 1 <> 1 then[128X[104X
    [4X[28X        return 1;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return 1;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that functions can be used multiple times in dst_template[127X[104X
    [4X[25X>[125X [27X# add a nonsense template[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "list", "value" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "List( list, l -> value )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "Sum( list, l -> value ) + Sum( list, l -> value )",[127X[104X
    [4X[25X>[125X [27X    returns_value := true,[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( list )[127X[104X
    [4X[25X>[125X [27X    return List( list, x -> x ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( list_1 )[128X[104X
    [4X[28X    return Sum( list_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end ) + Sum( list_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( list )[127X[104X
    [4X[25X>[125X [27X    return List( list, x -> (y -> y) ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( list_1 )[128X[104X
    [4X[28X    return Sum( list_1, function ( x_2 )[128X[104X
    [4X[28X              return function ( y_3 )[128X[104X
    [4X[28X                    return y_3;[128X[104X
    [4X[28X                end;[128X[104X
    [4X[28X          end ) + Sum( list_1, function ( x_2 )[128X[104X
    [4X[28X              return function ( y_3 )[128X[104X
    [4X[28X                    return y_3;[128X[104X
    [4X[28X                end;[128X[104X
    [4X[28X          end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that functions with assignments to local variables do not match[127X[104X
    [4X[25X>[125X [27X# logic templates without assignments to local variables[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "value" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "List( [ 1 ], l -> value )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "(l -> value)(1)",[127X[104X
    [4X[25X>[125X [27X    returns_value := true,[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 ], function ( y )[127X[104X
    [4X[25X>[125X [27X        local r; r := x; return r; end ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return List( [ 1 ], function ( y_2 )[128X[104X
    [4X[28X            local r_2;[128X[104X
    [4X[28X            r_2 := x_1;[128X[104X
    [4X[28X            return r_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that values are pulled out iff[127X[104X
    [4X[25X>[125X [27X# they are independent of local variables[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "list", "value" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "List( list, l -> value * l )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "value * List( list, l -> l )",[127X[104X
    [4X[25X>[125X [27X    returns_value := true,[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := L -> List( L, l -> l * l );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( L_1 )[128X[104X
    [4X[28X    return List( L_1, function ( l_2 )[128X[104X
    [4X[28X            return l_2 * l_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := L -> List( L, l -> 2 * l );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, [ ] ) );[127X[104X
    [4X[28Xfunction ( L_1 )[128X[104X
    [4X[28X    return 2 * List( L_1, function ( l_2 )[128X[104X
    [4X[28X              return l_2;[128X[104X
    [4X[28X          end );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc := x -> x[1,1];;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitResolvedGlobalVariables( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return MatElm( x_1, 1, 1 );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "FreydCategoriesForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationalsInSingular( );;[127X[104X
    [4X[25Xgap>[125X [27XQQxy := QQ * "x,y";;[127X[104X
    [4X[25Xgap>[125X [27XEEE := KoszulDualRing( QQxy );;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_CategoryOfColumns := function( homalg_ring, name )[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    CapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X        homalg_ring -> CategoryOfColumnsAsOppositeOfCategoryOfRows([127X[104X
    [4X[25X>[125X [27X            homalg_ring[127X[104X
    [4X[25X>[125X [27X        ),[127X[104X
    [4X[25X>[125X [27X        [ homalg_ring ],[127X[104X
    [4X[25X>[125X [27X        "FreydCategoriesForCAP",[127X[104X
    [4X[25X>[125X [27X        Concatenation([127X[104X
    [4X[25X>[125X [27X            "CategoryOfColumnsAsOppositeOfCategoryOfRowsOf",[127X[104X
    [4X[25X>[125X [27X            name,[127X[104X
    [4X[25X>[125X [27X            "Precompiled"[127X[104X
    [4X[25X>[125X [27X        ) :[127X[104X
    [4X[25X>[125X [27X        operations := "primitive"[127X[104X
    [4X[25X>[125X [27X    ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_CategoryOfColumns( QQ, "Field" );;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_CategoryOfColumns( QQxy, "CommutativeRing" );;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_CategoryOfColumns( EEE, "ArbitraryRing" );;[127X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27X# be careful not to use `MatrixCategory` because attributes are not supported[127X[104X
    [4X[25X>[125X [27Xcategory_constructor := function( field )[127X[104X
    [4X[25X>[125X [27X  return Opposite( MATRIX_CATEGORY( field : FinalizeCategory := true ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xgiven_arguments := [ QQ ];;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_category_name := "OppositeOfMatrixCategoryPrecompiled";;[127X[104X
    [4X[25Xgap>[125X [27Xpackage_name := "LinearAlgebraForCAP";;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := Intersection([127X[104X
    [4X[25X>[125X [27X    ListPrimitivelyInstalledOperationsOfCategory( MatrixCategory( QQ ) ),[127X[104X
    [4X[25X>[125X [27X    CAP_JIT_INTERNAL_SAFE_OPERATIONS[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27X# The output for Lift/ColiftOrFail differs between GAP 4.11 and GAP 4.12, see[127X[104X
    [4X[25X>[125X [27X# https://github.com/gap-system/gap/issues/4523[127X[104X
    [4X[25X>[125X [27Xoperations := Difference( operations, [ "LiftOrFail", "ColiftOrFail" ] );;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X    category_constructor,[127X[104X
    [4X[25X>[125X [27X    given_arguments,[127X[104X
    [4X[25X>[125X [27X    package_name,[127X[104X
    [4X[25X>[125X [27X    compiled_category_name :[127X[104X
    [4X[25X>[125X [27X    operations := operations[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XReadPackage([127X[104X
    [4X[25X>[125X [27X    "LinearAlgebraForCAP",[127X[104X
    [4X[25X>[125X [27X    "gap/precompiled_categories/OppositeOfMatrixCategoryPrecompiled.gi"[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XOppositeOfMatrixCategoryPrecompiled( QQ );[127X[104X
    [4X[28XOpposite of Category of matrices over Q[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQ := HomalgFieldOfRationals();;[127X[104X
    [4X[25Xgap>[125X [27Xvec := MATRIX_CATEGORY( Q : enable_compilation := true );;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( cat, x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    return ZeroObject( cat ); end;;[127X[104X
    [4X[25Xgap>[125X [27X# make sure that ZeroObject( cat ) is not resolved to a global variable[127X[104X
    [4X[25X>[125X [27XDisplay( CapJitCompiledFunction( { cat, x } -> func( cat, x ), [ vec ] ) );[127X[104X
    [4X[28Xfunction ( cat_1, x_1 )[128X[104X
    [4X[28X    return ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Dimension, 0 );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  local x; x := { args... } -> 1; return x( ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, [ ] ) );[127X[104X
    [4X[28Xfunction ( )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc1 := function( x, y )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    return x; end;;[127X[104X
    [4X[25Xgap>[125X [27Xfunc2 := function( )[127X[104X
    [4X[25X>[125X [27X  local var; var := 1; var := func1( 2, var ); return var; end;;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := CapJitCompiledFunction( func2, [] );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func();[127X[104X
    [4X[28X2[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc := function( )[127X[104X
    [4X[25X>[125X [27X  local id; id := y -> y; return [ id, id ]; end;;[127X[104X
    [4X[25Xgap>[125X [27X# we are not interested in the output, but only that this does not throw[127X[104X
    [4X[25X>[125X [27X# an error due to some function id being used multiple times[127X[104X
    [4X[25X>[125X [27XCapJitCompiledFunction( func, [ ] );;[127X[104X
  [4X[32X[104X
  
