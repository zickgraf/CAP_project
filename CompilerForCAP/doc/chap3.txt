  
  [1X3 [33X[0;0YExamples and tests[133X[101X
  
  
  [1X3.1 [33X[0;0YExamples[133X[101X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# make tests deterministic[127X[104X
    [4X[25X>[125X [27Xoriginal_func_id := CAP_JIT_INTERNAL_FUNCTION_ID;;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := 1;;[127X[104X
    [4X[25Xgap>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local a, b, c, d, e, f, g@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    a := 1@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x < 0 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        b := 2@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        c := 3@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    elif x = 1 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        c := b@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    else[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        d := a@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        c := a@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    e := c@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x < 0 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return a@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    elif x = 1 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return c@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    else[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        f := d@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        g := f@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return g@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrettyPrintSyntaxTree( tree );[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  0_type := "EXPR_DECLARATIVE_FUNC",[128X[104X
    [4X[28X  1_id := 1,[128X[104X
    [4X[28X  2_nams := [ "x", "a", "b", "c", "d", "e", "f", "g", "RETURN_VALUE" ],[128X[104X
    [4X[28X  3_narg := 1,[128X[104X
    [4X[28X  4_variadic := false,[128X[104X
    [4X[28X  5_bindings := rec([128X[104X
    [4X[28X      0_type := "FVAR_BINDING_SEQ",[128X[104X
    [4X[28X      1_names := [ "RETURN_VALUE", "a", "b", "c", "d", "e", "f", "g" ],[128X[104X
    [4X[28X      2_BINDING_RETURN_VALUE := rec([128X[104X
    [4X[28X          0_type := "EXPR_CASE",[128X[104X
    [4X[28X          1_branches := rec([128X[104X
    [4X[28X              0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X              0_length := 3,[128X[104X
    [4X[28X              1 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_LT",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 0 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "a" ) ),[128X[104X
    [4X[28X              2 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_EQ",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 1 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "c" ) ),[128X[104X
    [4X[28X              3 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "g" ) ) ) ),[128X[104X
    [4X[28X      3_BINDING_a := rec([128X[104X
    [4X[28X          0_type := "EXPR_INT",[128X[104X
    [4X[28X          1_value := 1 ),[128X[104X
    [4X[28X      4_BINDING_b := rec([128X[104X
    [4X[28X          0_type := "EXPR_INT",[128X[104X
    [4X[28X          1_value := 2 ),[128X[104X
    [4X[28X      5_BINDING_c := rec([128X[104X
    [4X[28X          0_type := "EXPR_CASE",[128X[104X
    [4X[28X          1_branches := rec([128X[104X
    [4X[28X              0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X              0_length := 3,[128X[104X
    [4X[28X              1 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_LT",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 0 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_INT",[128X[104X
    [4X[28X                      1_value := 3 ) ),[128X[104X
    [4X[28X              2 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_EQ",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 1,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 1 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "b" ) ),[128X[104X
    [4X[28X              3 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                      1_func_id := 1,[128X[104X
    [4X[28X                      2_name := "a" ) ) ) ),[128X[104X
    [4X[28X      6_BINDING_d := rec([128X[104X
    [4X[28X          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X          1_func_id := 1,[128X[104X
    [4X[28X          2_name := "a" ),[128X[104X
    [4X[28X      7_BINDING_e := rec([128X[104X
    [4X[28X          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X          1_func_id := 1,[128X[104X
    [4X[28X          2_name := "c" ),[128X[104X
    [4X[28X      8_BINDING_f := rec([128X[104X
    [4X[28X          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X          1_func_id := 1,[128X[104X
    [4X[28X          2_name := "d" ),[128X[104X
    [4X[28X      9_BINDING_g := rec([128X[104X
    [4X[28X          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X          1_func_id := 1,[128X[104X
    [4X[28X          2_name := "f" ) ) )[128X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local a_1, b_1, c_1, d_1, e_1, f_1, g_1;[128X[104X
    [4X[28X    a_1 := 1;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        c_1 := 3;[128X[104X
    [4X[28X    elif x_1 = 1 then[128X[104X
    [4X[28X        b_1 := 2;[128X[104X
    [4X[28X        c_1 := b_1;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        c_1 := a_1;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        return a_1;[128X[104X
    [4X[28X    elif x_1 = 1 then[128X[104X
    [4X[28X        return c_1;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        d_1 := a_1;[128X[104X
    [4X[28X        f_1 := d_1;[128X[104X
    [4X[28X        g_1 := f_1;[128X[104X
    [4X[28X        return g_1;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    e_1 := c_1;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local y@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x < 0 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        Error( "error" )@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if x = 1 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return true@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    y := 2@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return false@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrettyPrintSyntaxTree( tree );[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  0_type := "EXPR_DECLARATIVE_FUNC",[128X[104X
    [4X[28X  1_id := 2,[128X[104X
    [4X[28X  2_nams := [ "x", "y", "RETURN_VALUE" ],[128X[104X
    [4X[28X  3_narg := 1,[128X[104X
    [4X[28X  4_variadic := false,[128X[104X
    [4X[28X  5_bindings := rec([128X[104X
    [4X[28X      0_type := "FVAR_BINDING_SEQ",[128X[104X
    [4X[28X      1_names := [ "RETURN_VALUE", "y" ],[128X[104X
    [4X[28X      2_BINDING_RETURN_VALUE := rec([128X[104X
    [4X[28X          0_type := "EXPR_CASE",[128X[104X
    [4X[28X          1_branches := rec([128X[104X
    [4X[28X              0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X              0_length := 2,[128X[104X
    [4X[28X              1 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_EQ",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_REF_FVAR",[128X[104X
    [4X[28X                          1_func_id := 2,[128X[104X
    [4X[28X                          2_name := "x" ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 1 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ) ),[128X[104X
    [4X[28X              2 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_FALSE" ) ) ) ),[128X[104X
    [4X[28X      3_BINDING_y := rec([128X[104X
    [4X[28X          0_type := "EXPR_INT",[128X[104X
    [4X[28X          1_value := 2 ) ) )[128X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := original_func_id;;[127X[104X
    [4X[25Xgap>[125X [27X# check that function stack depth is removed[127X[104X
    [4X[25X>[125X [27Xfunc := x -> y -> 1;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xfunc2 := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xtree2 := ENHANCED_SYNTAX_TREE( func2 );;[127X[104X
    [4X[25Xgap>[125X [27Xtree.nams = tree2.nams;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xtree.bindings.BINDING_RETURN_VALUE.nams =[127X[104X
    [4X[25X>[125X [27X    tree2.bindings.BINDING_RETURN_VALUE.nams;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# test CAP_JIT_INTERNAL_EXPR_CASE[127X[104X
    [4X[25X>[125X [27Xfunc := { } -> CAP_JIT_INTERNAL_EXPR_CASE( 1 <> 1, 1, true, 2 );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrettyPrintSyntaxTree( tree );[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  0_type := "EXPR_DECLARATIVE_FUNC",[128X[104X
    [4X[28X  1_id := 1000000004,[128X[104X
    [4X[28X  2_nams := [ "RETURN_VALUE" ],[128X[104X
    [4X[28X  3_narg := 0,[128X[104X
    [4X[28X  4_variadic := false,[128X[104X
    [4X[28X  5_bindings := rec([128X[104X
    [4X[28X      0_type := "FVAR_BINDING_SEQ",[128X[104X
    [4X[28X      1_names := [ "RETURN_VALUE" ],[128X[104X
    [4X[28X      2_BINDING_RETURN_VALUE := rec([128X[104X
    [4X[28X          0_type := "EXPR_CASE",[128X[104X
    [4X[28X          1_branches := rec([128X[104X
    [4X[28X              0__type := "SYNTAX_TREE_LIST",[128X[104X
    [4X[28X              0_length := 2,[128X[104X
    [4X[28X              1 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_NE",[128X[104X
    [4X[28X                      1_left := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 1 ),[128X[104X
    [4X[28X                      2_right := rec([128X[104X
    [4X[28X                          0_type := "EXPR_INT",[128X[104X
    [4X[28X                          1_value := 1 ) ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_INT",[128X[104X
    [4X[28X                      1_value := 1 ) ),[128X[104X
    [4X[28X              2 := rec([128X[104X
    [4X[28X                  0_type := "CASE_BRANCH",[128X[104X
    [4X[28X                  1_condition := rec([128X[104X
    [4X[28X                      0_type := "EXPR_TRUE" ),[128X[104X
    [4X[28X                  2_value := rec([128X[104X
    [4X[28X                      0_type := "EXPR_INT",[128X[104X
    [4X[28X                      1_value := 2 ) ) ) ) ) )[128X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    if 1 <> 1 then[128X[104X
    [4X[28X        return 1;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return 2;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQ := HomalgFieldOfRationals();;[127X[104X
    [4X[25Xgap>[125X [27Xvec := MATRIX_CATEGORY( Q : no_precompiled_code := true );;[127X[104X
    [4X[25Xgap>[125X [27XV := MatrixCategoryObject( vec, 2 );;[127X[104X
    [4X[25Xgap>[125X [27Xalpha := ZeroMorphism( V, V );;[127X[104X
    [4X[25Xgap>[125X [27Xbeta := IdentityMorphism( V );;[127X[104X
    [4X[25Xgap>[125X [27XW := DirectSum( V, V );;[127X[104X
    [4X[25Xgap>[125X [27Xmorphism_matrix := [ [ alpha, beta ], [ beta, alpha ] ];;[127X[104X
    [4X[25Xgap>[125X [27X# compile the primitive installation of[127X[104X
    [4X[25X>[125X [27X# MorphismBetweenDirectSumsWithGivenDirectSums[127X[104X
    [4X[25X>[125X [27XDisplay([127X[104X
    [4X[25X>[125X [27X    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[3][1][127X[104X
    [4X[25X>[125X [27X);[127X[104X
    [4X[28Xfunction ( cat, S, diagram_S, morphism_matrix, diagram_T, T )[128X[104X
    [4X[28X    local underlying_matrix;[128X[104X
    [4X[28X    underlying_matrix := List( morphism_matrix, function ( row )[128X[104X
    [4X[28X            return List( row, UnderlyingMatrix );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    underlying_matrix := ListN( diagram_S, underlying_matrix, [128X[104X
    [4X[28X       function ( source, row )[128X[104X
    [4X[28X            return UnionOfColumns( homalg_field, Dimension( source ), row );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return [128X[104X
    [4X[28X     VectorSpaceMorphism( cat, S, UnionOfRows( homalg_field, Dimension( T ), [128X[104X
    [4X[28X         underlying_matrix ), T );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xcompiled_func1 := CapJitCompiledFunction([127X[104X
    [4X[25X>[125X [27X    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[3][1],[127X[104X
    [4X[25X>[125X [27X    vec[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func1 );[127X[104X
    [4X[28Xfunction ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )[128X[104X
    [4X[28X    local hoisted_1_1, deduped_2_1;[128X[104X
    [4X[28X    deduped_2_1 := UnderlyingRing( cat_1 );[128X[104X
    [4X[28X    hoisted_1_1 := deduped_2_1;[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, S_1, T_1, UnderlyingMatrix, [128X[104X
    [4X[28X       UnionOfRows( deduped_2_1, Dimension( T_1 ), [128X[104X
    [4X[28X         ListN( diagram_S_1, List( morphism_matrix_1, function ( row_2 )[128X[104X
    [4X[28X                  return List( row_2, UnderlyingMatrix );[128X[104X
    [4X[28X              end ), function ( source_2, row_2 )[128X[104X
    [4X[28X                return UnionOfColumns( hoisted_1_1, Dimension( source_2 ), [128X[104X
    [4X[28X                   row_2 );[128X[104X
    [4X[28X            end ) ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# compile the default derivation of[127X[104X
    [4X[25X>[125X [27X# MorphismBetweenDirectSumsWithGivenDirectSums[127X[104X
    [4X[25X>[125X [27XDisplay([127X[104X
    [4X[25X>[125X [27X    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1][127X[104X
    [4X[25X>[125X [27X);[127X[104X
    [4X[28Xfunction ( cat, S, diagram_S, morphism_matrix, diagram_T, T )[128X[104X
    [4X[28X    local test_diagram_product, test_diagram_coproduct;[128X[104X
    [4X[28X    test_diagram_coproduct := ListN( diagram_S, morphism_matrix, [128X[104X
    [4X[28X       function ( source, row )[128X[104X
    [4X[28X            return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, [128X[104X
    [4X[28X               diagram_T, source, row, T );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, diagram_S, [128X[104X
    [4X[28X       T, test_diagram_coproduct, S );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xcompiled_func2 := CapJitCompiledFunction([127X[104X
    [4X[25X>[125X [27X    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1],[127X[104X
    [4X[25X>[125X [27X    vec[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func2 );[127X[104X
    [4X[28Xfunction ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )[128X[104X
    [4X[28X    local hoisted_1_1, deduped_2_1;[128X[104X
    [4X[28X    deduped_2_1 := UnderlyingRing( cat_1 );[128X[104X
    [4X[28X    hoisted_1_1 := deduped_2_1;[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, S_1, T_1, UnderlyingMatrix, [128X[104X
    [4X[28X       UnionOfRows( deduped_2_1, Dimension( T_1 ), [128X[104X
    [4X[28X         ListN( diagram_S_1, morphism_matrix_1, [128X[104X
    [4X[28X           function ( logic_new_func_x_2, logic_new_func_y_2 )[128X[104X
    [4X[28X                return [128X[104X
    [4X[28X                 UnionOfColumns( hoisted_1_1, Dimension( logic_new_func_x_2 )[128X[104X
    [4X[28X                    , List( logic_new_func_y_2, function ( s_3 )[128X[104X
    [4X[28X                          return UnderlyingMatrix( s_3 );[128X[104X
    [4X[28X                      end ) );[128X[104X
    [4X[28X            end ) ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE([127X[104X
    [4X[25X>[125X [27X    CapJitCompiledCAPOperationAsEnhancedSyntaxTree( vec, "KernelEmbedding" )[127X[104X
    [4X[25X>[125X [27X) );[127X[104X
    [4X[28Xfunction ( cat_1, morphism_1 )[128X[104X
    [4X[28X    local morphism_attr_1_1;[128X[104X
    [4X[28X    morphism_attr_1_1 := SyzygiesOfRows( UnderlyingMatrix( morphism_1 ) );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X             ), cat_1, Dimension, NumberRows( morphism_attr_1_1 ) ), [128X[104X
    [4X[28X       Source( morphism_1 ), UnderlyingMatrix, morphism_attr_1_1 );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XReadPackage( "LinearAlgebraForCAP", "gap/CompilerLogic.gi" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27X# be careful not to use `MatrixCategory` because attributes are not supported[127X[104X
    [4X[25X>[125X [27Xcategory_constructor := field -> MATRIX_CATEGORY( field );;[127X[104X
    [4X[25Xgap>[125X [27Xgiven_arguments := [ QQ ];;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_category_name := "MatrixCategoryPrecompiled";;[127X[104X
    [4X[25Xgap>[125X [27Xpackage_name := "LinearAlgebraForCAP";;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X    category_constructor,[127X[104X
    [4X[25X>[125X [27X    given_arguments,[127X[104X
    [4X[25X>[125X [27X    package_name,[127X[104X
    [4X[25X>[125X [27X    compiled_category_name[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XMatrixCategoryPrecompiled( QQ );[127X[104X
    [4X[28XCategory of matrices over Q[128X[104X
    [4X[25Xgap>[125X [27X# check that the compiled code is loaded automatically[127X[104X
    [4X[25X>[125X [27X# for this, we use the name of the argument of `ZeroObject`:[127X[104X
    [4X[25X>[125X [27X# for non-compiled code it is "cat", while for compiled code it is "cat_1"[127X[104X
    [4X[25X>[125X [27Xcat := MatrixCategory( QQ );;[127X[104X
    [4X[25Xgap>[125X [27XNamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1];[127X[104X
    [4X[28X"cat_1"[128X[104X
  [4X[32X[104X
  
  
  [1X3.2 [33X[0;0YTests[133X[101X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_DROP_NEXT_STATEMENT[127X[104X
    [4X[25X>[125X [27X    Display( 1 ); return 1; end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func ) );[127X[104X
    [4X[28Xfunction ( )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27Xcat := MatrixCategory( QQ );;[127X[104X
    [4X[25Xgap>[125X [27X# CapFixpoint with object[127X[104X
    [4X[25X>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function( cat )[127X[104X
    [4X[25X>[125X [27X  local predicate, func, initial_value@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    predicate := { x, y } -> Dimension( x ) = 3 and Dimension( y ) = 2@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    func := x -> MatrixCategoryObject( cat, Dimension( x ) - 1 )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    initial_value := MatrixCategoryObject( cat, 10 )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return CapFixpoint( predicate, func, initial_value )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xfunc( cat );[127X[104X
    [4X[28X<A vector space object over Q of dimension 2>[128X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, cat ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Dimension, CapFixpoint( function ( x_2, y_2 )[128X[104X
    [4X[28X              return x_2 = 3 and y_2 = 2;[128X[104X
    [4X[28X          end, function ( x_2 )[128X[104X
    [4X[28X              return x_2 - 1;[128X[104X
    [4X[28X          end, 10 ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# CapFixpoint with morphism[127X[104X
    [4X[25X>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function( cat )[127X[104X
    [4X[25X>[125X [27X  local obj, predicate, func, initial_value@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    obj := MatrixCategoryObject( cat, 1 )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    predicate := { x, y } -> IsZeroForMorphisms( cat, y )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    func := x -> SubtractionForMorphisms( cat, x, x )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    initial_value := IdentityMorphism( cat, obj )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return CapFixpoint( predicate, func, initial_value )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xfunc( cat );[127X[104X
    [4X[28X<A morphism in Category of matrices over Q>[128X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, cat ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    local morphism_attr_1_1, deduped_2_1;[128X[104X
    [4X[28X    deduped_2_1 := ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Dimension, 1 );[128X[104X
    [4X[28X    morphism_attr_1_1 := CapFixpoint( function ( x_2, y_2 )[128X[104X
    [4X[28X            return IsZero( y_2 );[128X[104X
    [4X[28X        end, function ( x_2 )[128X[104X
    [4X[28X            return x_2 + -1 * x_2;[128X[104X
    [4X[28X        end, HomalgIdentityMatrix( 1, UnderlyingRing( cat_1 ) ) );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, deduped_2_1, deduped_2_1, UnderlyingMatrix, [128X[104X
    [4X[28X       morphism_attr_1_1 );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# Iterated with list[127X[104X
    [4X[25X>[125X [27Xfunc := { cat, alpha, beta, gamma } ->[127X[104X
    [4X[25X>[125X [27X    Iterated([127X[104X
    [4X[25X>[125X [27X        [ alpha, beta, gamma ],[127X[104X
    [4X[25X>[125X [27X        { alpha, beta } -> PreCompose( cat, alpha, beta )[127X[104X
    [4X[25X>[125X [27X    );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, cat ) );[127X[104X
    [4X[28Xfunction ( cat_1, alpha_1, beta_1, gamma_1 )[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Source( alpha_1 ), Range( gamma_1 ), UnderlyingMatrix, [128X[104X
    [4X[28X       UnderlyingMatrix( alpha_1 ) * UnderlyingMatrix( beta_1 ) [128X[104X
    [4X[28X        * UnderlyingMatrix( gamma_1 ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# Iterated (case: from_initial_value)[127X[104X
    [4X[25X>[125X [27X# PreComposeList[127X[104X
    [4X[25X>[125X [27Xfunc := { cat, morphism_list } ->[127X[104X
    [4X[25X>[125X [27X    Iterated([127X[104X
    [4X[25X>[125X [27X        morphism_list,[127X[104X
    [4X[25X>[125X [27X        { alpha, beta } -> AdditionForMorphisms( cat, alpha, beta )[127X[104X
    [4X[25X>[125X [27X    );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, cat ) );[127X[104X
    [4X[28Xfunction ( cat_1, morphism_list_1 )[128X[104X
    [4X[28X    local deduped_1_1;[128X[104X
    [4X[28X    deduped_1_1 := morphism_list_1[1];[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Source( deduped_1_1 ), Range( deduped_1_1 ), [128X[104X
    [4X[28X       UnderlyingMatrix, Iterated( List( morphism_list_1, UnderlyingMatrix )[128X[104X
    [4X[28X          , function ( alpha_2, beta_2 )[128X[104X
    [4X[28X              return alpha_2 + beta_2;[128X[104X
    [4X[28X          end ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# Iterated (case: from_compiler_hints)[127X[104X
    [4X[25X>[125X [27X# PreComposeList[127X[104X
    [4X[25X>[125X [27Xfunc := { cat, morphism_list } ->[127X[104X
    [4X[25X>[125X [27X    Iterated([127X[104X
    [4X[25X>[125X [27X        morphism_list,[127X[104X
    [4X[25X>[125X [27X        { alpha, beta } -> PreCompose( cat, alpha, beta )[127X[104X
    [4X[25X>[125X [27X    );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, cat ) );[127X[104X
    [4X[28Xfunction ( cat_1, morphism_list_1 )[128X[104X
    [4X[28X    local morphism_attr_1_1;[128X[104X
    [4X[28X    morphism_attr_1_1 := Iterated( List( morphism_list_1, UnderlyingMatrix ), [128X[104X
    [4X[28X       function ( alpha_2, beta_2 )[128X[104X
    [4X[28X            return alpha_2 * beta_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X             ), cat_1, Dimension, NumberRows( morphism_attr_1_1 ) ), [128X[104X
    [4X[28X       ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X             ), cat_1, Dimension, NumberColumns( morphism_attr_1_1 ) ), [128X[104X
    [4X[28X       UnderlyingMatrix, morphism_attr_1_1 );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQ := HomalgFieldOfRationals();;[127X[104X
    [4X[25Xgap>[125X [27Xrows := MatrixCategory( Q );;[127X[104X
    [4X[25Xgap>[125X [27XMyKernelLift := function( cat, mor, test_mor )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL[127X[104X
    [4X[25X>[125X [27X    return LiftOrFail( cat, test_mor, KernelEmbedding( cat, mor ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27XV := VectorSpaceObject( 2, Q );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := CapJitCompiledFunction( MyKernelLift, rows );;[127X[104X
    [4X[28XWARNING: Compiling CAP operation LiftOrFail with return_type morphism_or_fail.\[128X[104X
    [4X[28X Operations returning fail usually do not fulfill the requirements that all br\[128X[104X
    [4X[28Xanches of an if statement can be executed even if the corresponding condition \[128X[104X
    [4X[28Xdoes not hold. This might cause errors.[128X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( cat_1, mor_1, test_mor_1 )[128X[104X
    [4X[28X    local morphism_attr_1_1;[128X[104X
    [4X[28X    morphism_attr_1_1 := RightDivide( UnderlyingMatrix( test_mor_1 ), [128X[104X
    [4X[28X       SyzygiesOfRows( UnderlyingMatrix( mor_1 ) ) );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Source( test_mor_1 ), [128X[104X
    [4X[28X       ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X             ), cat_1, Dimension, NumberColumns( morphism_attr_1_1 ) ), [128X[104X
    [4X[28X       UnderlyingMatrix, morphism_attr_1_1 );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc1 := function( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    if x = 1 then return fail; fi; return 1; end;;[127X[104X
    [4X[25Xgap>[125X [27Xfunc2 := function( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    if x = 1 then return fail; else return 1; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xcall_func1 := function( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL[127X[104X
    [4X[25X>[125X [27X    return func1( x ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xcall_func2 := function( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL[127X[104X
    [4X[25X>[125X [27X    return func2( x ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( call_func1 ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( call_func2 ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XDeclareFilter( "IsMyCat1", IsCapCategory );;[127X[104X
    [4X[25Xgap>[125X [27XDeclareFilter( "IsMyCat2", IsCapCategory );;[127X[104X
    [4X[25Xgap>[125X [27XDeclareOperation( "MyOperation", [ IsMyCat1 ] );;[127X[104X
    [4X[25Xgap>[125X [27XDeclareOperation( "MyOperation", [ IsMyCat2 ] );;[127X[104X
    [4X[25Xgap>[125X [27XInstallMethodForCompilerForCAP( MyOperation, [ IsMyCat1 ], cat -> 1 );[127X[104X
    [4X[25Xgap>[125X [27XInstallMethodForCompilerForCAP( MyOperation, [ IsMyCat2 ], cat -> 2 );[127X[104X
    [4X[25Xgap>[125X [27XInstallOtherMethodForCompilerForCAP([127X[104X
    [4X[25X>[125X [27X    MyOperation,[127X[104X
    [4X[25X>[125X [27X    [ IsMyCat2, IsInt ],[127X[104X
    [4X[25X>[125X [27X    { cat, int } -> 3[127X[104X
    [4X[25X>[125X [27X);[127X[104X
    [4X[25Xgap>[125X [27Xcat1 := CreateCapCategory( "cat1" );;[127X[104X
    [4X[25Xgap>[125X [27Xcat2 := CreateCapCategory( "cat2" );;[127X[104X
    [4X[25Xgap>[125X [27XSetFilterObj( cat1, IsMyCat1 );[127X[104X
    [4X[25Xgap>[125X [27XSetFilterObj( cat2, IsMyCat2 );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( cat -> MyOperation( cat ), cat1 ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( cat -> MyOperation( cat ), cat2 ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return 2;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( cat -> MyOperation( cat, 1 ), cat2 ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return 3;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQ := HomalgFieldOfRationals();;[127X[104X
    [4X[25Xgap>[125X [27Xvec := MATRIX_CATEGORY( Q );;[127X[104X
    [4X[25Xgap>[125X [27X# test CapJitCompiledFunction with explicit type signature[127X[104X
    [4X[25X>[125X [27XDisplay([127X[104X
    [4X[25X>[125X [27X    CapJitCompiledFunction([127X[104X
    [4X[25X>[125X [27X        cat -> ZeroObject( cat ),[127X[104X
    [4X[25X>[125X [27X        [[127X[104X
    [4X[25X>[125X [27X            [[127X[104X
    [4X[25X>[125X [27X                rec([127X[104X
    [4X[25X>[125X [27X                    filter := IsCapCategory,[127X[104X
    [4X[25X>[125X [27X                    category := vec[127X[104X
    [4X[25X>[125X [27X                )[127X[104X
    [4X[25X>[125X [27X            ],[127X[104X
    [4X[25X>[125X [27X            fail,[127X[104X
    [4X[25X>[125X [27X        ][127X[104X
    [4X[25X>[125X [27X    )[127X[104X
    [4X[25X>[125X [27X);[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Dimension, 0 );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# duplicate code inside a function[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> (y + (x + 1)) + (y + (x + 1)) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            local deduped_1_2;[128X[104X
    [4X[28X            deduped_1_2 := y_2 + (x_1 + 1);[128X[104X
    [4X[28X            return deduped_1_2 + deduped_1_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# duplicate code inside duplicate code[127X[104X
    [4X[25X>[125X [27Xfunc := function( x, y )[127X[104X
    [4X[25X>[125X [27X    return (y + (x + 1) + (x + 1)) + (y + (x + 1) + (x + 1)); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1, y_1 )[128X[104X
    [4X[28X    local deduped_1_1, deduped_2_1;[128X[104X
    [4X[28X    deduped_2_1 := x_1 + 1;[128X[104X
    [4X[28X    deduped_1_1 := y_1 + deduped_2_1 + deduped_2_1;[128X[104X
    [4X[28X    return deduped_1_1 + deduped_1_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# don't deduplicate code accross functions[127X[104X
    [4X[25X>[125X [27Xfunc := function( )[127X[104X
    [4X[25X>[125X [27X    return [ [ x -> (x + 1) + 2 ], [ x -> (x + 1) + 3 ] ]; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return [ [ function ( x_2 )[128X[104X
    [4X[28X                  return x_2 + 1 + 2;[128X[104X
    [4X[28X              end ], [ function ( x_2 )[128X[104X
    [4X[28X                  return x_2 + 1 + 3;[128X[104X
    [4X[28X              end ] ];[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# duplicate code inside duplicate code at different function levels[127X[104X
    [4X[25X>[125X [27Xfunc := {} ->[127X[104X
    [4X[25X>[125X [27X    y -> [ [ y, x -> (x + 1) + (x + 1) ], [ y, x -> (x + 1) + (x + 1) ] ];;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return function ( y_2 )[128X[104X
    [4X[28X          local deduped_1_2;[128X[104X
    [4X[28X          deduped_1_2 := [ y_2, function ( x_3 )[128X[104X
    [4X[28X                    local deduped_1_3;[128X[104X
    [4X[28X                    deduped_1_3 := x_3 + 1;[128X[104X
    [4X[28X                    return deduped_1_3 + deduped_1_3;[128X[104X
    [4X[28X                end ];[128X[104X
    [4X[28X          return [ deduped_1_2, deduped_1_2 ];[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# deduplication after hoisting in duplicated code[127X[104X
    [4X[25X>[125X [27Xfunc := { f, L } ->[127X[104X
    [4X[25X>[125X [27X    [ f( y -> List( L, l -> y + y ) ), f( y -> List( L, l -> y + y ) ) ];;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( f_1, L_1 )[128X[104X
    [4X[28X    local deduped_1_1;[128X[104X
    [4X[28X    deduped_1_1 := f_1( function ( y_2 )[128X[104X
    [4X[28X            local hoisted_1_2;[128X[104X
    [4X[28X            hoisted_1_2 := y_2 + y_2;[128X[104X
    [4X[28X            return List( L_1, function ( l_3 )[128X[104X
    [4X[28X                    return hoisted_1_2;[128X[104X
    [4X[28X                end );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return [ deduped_1_1, deduped_1_1 ];[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# make sure that ignoring paths in replaced paths works as expected[127X[104X
    [4X[25X>[125X [27Xfunc := {} ->[127X[104X
    [4X[25X>[125X [27X    [ [ [ [ 1 ] ], [ [ 1 ] ] ], [ [ [ 1 ] ], [ [ 1 ] ] ] ];;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDeduplicatedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local deduped_1_1, deduped_2_1;[128X[104X
    [4X[28X    deduped_2_1 := [ [ 1 ] ];[128X[104X
    [4X[28X    deduped_1_1 := [ deduped_2_1, deduped_2_1 ];[128X[104X
    [4X[28X    return [ deduped_1_1, deduped_1_1 ];[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xfunc := list -> Sum( list[1] );;[127X[104X
    [4X[25Xgap>[125X [27Xtype_signature := [[127X[104X
    [4X[25X>[125X [27X    [[127X[104X
    [4X[25X>[125X [27X        rec([127X[104X
    [4X[25X>[125X [27X            filter := IsList,[127X[104X
    [4X[25X>[125X [27X            element_type := rec([127X[104X
    [4X[25X>[125X [27X                filter := IsList,[127X[104X
    [4X[25X>[125X [27X                element_type := rec([127X[104X
    [4X[25X>[125X [27X                    filter := IsInt,[127X[104X
    [4X[25X>[125X [27X                ),[127X[104X
    [4X[25X>[125X [27X            ),[127X[104X
    [4X[25X>[125X [27X        ),[127X[104X
    [4X[25X>[125X [27X    ],[127X[104X
    [4X[25X>[125X [27X    fail,[127X[104X
    [4X[25X>[125X [27X];;[127X[104X
    [4X[25Xgap>[125X [27XCapJitDisableDataTypeInference( );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, type_signature ) );[127X[104X
    [4X[28Xfunction ( list_1 )[128X[104X
    [4X[28X    return Sum( list_1[1] );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XCapJitEnableDataTypeInference( );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, type_signature ) );[127X[104X
    [4X[28Xfunction ( list_1 )[128X[104X
    [4X[28X    return List( list_1, Sum )[1];[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local inner_func1, inner_func2@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    inner_func1 := function( y )[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        if y < 1 or y > 10 then[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 1@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        elif y > 10 then[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 2@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        else[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 3@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        fi@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    end@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    inner_func2 := function( y )[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        if y < 1 then[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 5@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        elif y > 10 then[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 6@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        elif y < 1 or y > 10 then[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 7@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        else[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X            return 8@[127X[104X
    [4X[25X>[125X [27X            [127X[104X
    [4X[25X>[125X [27X        fi@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    end@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    if IdFunc( false ) then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return 0@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    elif x < 1 or x > 10 then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return inner_func1( x )@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    elif IdFunc( false ) then[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return 4@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    else[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return inner_func2( x )@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    fi@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := CapJitCompiledFunction( func );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    if x_1 < 1 or x_1 > 10 then[128X[104X
    [4X[28X        return 1;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return 8;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# check that CapJitDroppedUnusedBindings is idempotent[127X[104X
    [4X[25X>[125X [27X# (one function level)[127X[104X
    [4X[25X>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  local val1, val2; val1 := 1; val2 := val1; return 1; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDroppedUnusedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitDroppedUnusedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# check that CapJitDroppedUnusedBindings is idempotent[127X[104X
    [4X[25X>[125X [27X# (multiple function levels)[127X[104X
    [4X[25X>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local val1@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    val1 := 1@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return function ( )[127X[104X
    [4X[25X>[125X [27X      local val2@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        val2 := val1@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return 1@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    end@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitDroppedUnusedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return function (  )[128X[104X
    [4X[28X          return 1;[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitDroppedUnusedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return function (  )[128X[104X
    [4X[28X          return 1;[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xdummy := DummyCategory( rec([127X[104X
    [4X[25X>[125X [27X    list_of_operations_to_install := [[127X[104X
    [4X[25X>[125X [27X        "IdentityMorphism",[127X[104X
    [4X[25X>[125X [27X        "ZeroObject",[127X[104X
    [4X[25X>[125X [27X        "KernelObject",[127X[104X
    [4X[25X>[125X [27X    ],[127X[104X
    [4X[25X>[125X [27X) );;[127X[104X
    [4X[25Xgap>[125X [27XStopCompilationAtPrimitivelyInstalledOperationsOfCategory( dummy );[127X[104X
    [4X[25Xgap>[125X [27XCapJitEnableProofAssistantMode( );[127X[104X
    [4X[25Xgap>[125X [27Xfunc :=[127X[104X
    [4X[25X>[125X [27X    cat -> KernelObject( cat, IdentityMorphism( cat, ZeroObject( cat ) ) );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, dummy ) );[127X[104X
    [4X[28XWARNING: the CAP operation KernelObject is not compatible with the congruence \[128X[104X
    [4X[28Xof morphisms. Keep this in mind when writing logic templates.[128X[104X
    [4X[28XWARNING: the CAP operation KernelObject is not compatible with the congruence \[128X[104X
    [4X[28Xof morphisms. Keep this in mind when writing logic templates.[128X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return KernelObject( cat_1, IdentityMorphism( cat_1, ZeroObject( cat_1 ) [128X[104X
    [4X[28X         ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XCapJitDisableProofAssistantMode( );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, dummy ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return KernelObject( cat_1, IdentityMorphism( cat_1, ZeroObject( cat_1 ) [128X[104X
    [4X[28X         ) );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hoisting with deduplication[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> (y + (x + 1)) + (y + (x + 1)) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    hoisted_1_1 := x_1 + 1;[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return y_2 + hoisted_1_1 + (y_2 + hoisted_1_1);[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hoisting of whole functions[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> y + List( [ 1 .. 9 ], z -> x + z ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    hoisted_1_1 := List( [ 1 .. 9 ], function ( z_2 )[128X[104X
    [4X[28X            return x_1 + z_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return y_2 + hoisted_1_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# no hoisting of constants[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> y + 1 ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return y_2 + 1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hoisting of returned expressions[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> x + 1 ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    hoisted_1_1 := x_1 + 1;[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return hoisted_1_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hoisting of assigned expressions[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], function( y )[127X[104X
    [4X[25X>[125X [27X        local z; z := x + 1; return z; end ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    hoisted_1_1 := x_1 + 1;[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            local z_2;[128X[104X
    [4X[28X            z_2 := hoisted_1_1;[128X[104X
    [4X[28X            return z_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hosted expressions inside hosted expressions[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], function( y )[127X[104X
    [4X[25X>[125X [27X        return List( [ 1 .. 9 ], z -> z + (1 + 1) ); end ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local hoisted_1_1, hoisted_2_1;[128X[104X
    [4X[28X    hoisted_1_1 := 1 + 1;[128X[104X
    [4X[28X    hoisted_2_1 := List( [ 1 .. 9 ], function ( z_2 )[128X[104X
    [4X[28X            return z_2 + hoisted_1_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return hoisted_2_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# deduplication of more complex trees, e.g. functions[127X[104X
    [4X[25X>[125X [27Xfunc := function( list )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], function( y )[127X[104X
    [4X[25X>[125X [27X        return (y + Sum( list, a -> a )) + Sum( list, a -> a ); end ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( list_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    hoisted_1_1 := Sum( list_1, function ( a_2 )[128X[104X
    [4X[28X            return a_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return y_2 + hoisted_1_1 + hoisted_1_1;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# hosting of expressions in lists, e.g. function call arguments[127X[104X
    [4X[25X>[125X [27Xfunc := function( x, func )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 .. 9 ], y -> func( x + 1, x + 1, y ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1, func_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    hoisted_1_1 := x_1 + 1;[128X[104X
    [4X[28X    return List( [ 1 .. 9 ], function ( y_2 )[128X[104X
    [4X[28X            return func_1( hoisted_1_1, hoisted_1_1, y_2 );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X##[127X[104X
    [4X[25X>[125X [27X# restrict hoisting to if/else branches (where possible)[127X[104X
    [4X[25X>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    if x < 0 then return 0; else return y -> [ x + 1, z -> y + 1 ]; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        return 0;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        hoisted_1_1 := x_1 + 1;[128X[104X
    [4X[28X        return function ( y_2 )[128X[104X
    [4X[28X              local hoisted_1_2;[128X[104X
    [4X[28X              hoisted_1_2 := y_2 + 1;[128X[104X
    [4X[28X              return [ hoisted_1_1, function ( z_3 )[128X[104X
    [4X[28X                        return hoisted_1_2;[128X[104X
    [4X[28X                    end ];[128X[104X
    [4X[28X          end;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X    if x < 0 then return y -> [ x + 1, z -> y + 1 ]; else return 0; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        hoisted_1_1 := x_1 + 1;[128X[104X
    [4X[28X        return function ( y_2 )[128X[104X
    [4X[28X              local hoisted_1_2;[128X[104X
    [4X[28X              hoisted_1_2 := y_2 + 1;[128X[104X
    [4X[28X              return [ hoisted_1_1, function ( z_3 )[128X[104X
    [4X[28X                        return hoisted_1_2;[128X[104X
    [4X[28X                    end ];[128X[104X
    [4X[28X          end;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return 0;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function( x )[127X[104X
    [4X[25X>[125X [27X  if x < 0 then return y -> [ y, x+1 ]; else return y -> [ y, x+1 ]; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedExpressions( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local hoisted_1_1;[128X[104X
    [4X[28X    hoisted_1_1 := x_1 + 1;[128X[104X
    [4X[28X    if x_1 < 0 then[128X[104X
    [4X[28X        return function ( y_2 )[128X[104X
    [4X[28X              return [ y_2, hoisted_1_1 ];[128X[104X
    [4X[28X          end;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return function ( y_2 )[128X[104X
    [4X[28X              return [ y_2, hoisted_1_1 ];[128X[104X
    [4X[28X          end;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# CapJitHoistedBindings[127X[104X
    [4X[25X>[125X [27X[127X[104X
    [4X[25X>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc := EvalString( ReplacedString( """function (  )[127X[104X
    [4X[25X>[125X [27X  local var1, func1, func2@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    var1 := 1@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    func1 := function ( )[127X[104X
    [4X[25X>[125X [27X      local var2, var3@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        var2 := var1 + 1@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        var3 := var2 + 2@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return var3@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    end@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    func2 := function ( )[127X[104X
    [4X[25X>[125X [27X      local var4, var5@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        var4 := var1 + 1@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        var5 := var4 + 2@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X        return var5@[127X[104X
    [4X[25X>[125X [27X        [127X[104X
    [4X[25X>[125X [27X    end@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return [ func1, func2 ]@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitHoistedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local var1_1, func1_1, func2_1, hoisted_3_1, hoisted_4_1;[128X[104X
    [4X[28X    var1_1 := 1;[128X[104X
    [4X[28X    hoisted_3_1 := var1_1 + 1;[128X[104X
    [4X[28X    hoisted_4_1 := hoisted_3_1 + 2;[128X[104X
    [4X[28X    func2_1 := function (  )[128X[104X
    [4X[28X          return hoisted_4_1;[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28X    func1_1 := function (  )[128X[104X
    [4X[28X          return hoisted_4_1;[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28X    return [ func1_1, func2_1 ];[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# check that CapJitInlinedBindings is idempotent[127X[104X
    [4X[25X>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  local val1, val2; val1 := 1; val2 := val1; return val2; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitInlinedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitInlinedBindings( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# check that CapJitInlinedBindingsToVariableReferences is idempotent[127X[104X
    [4X[25X>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  local f1, f2; f1 := IdFunc; f2 := f1; return f2; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitInlinedBindingsToVariableReferences( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return IdFunc;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitInlinedBindingsToVariableReferences( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return IdFunc;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# make tests deterministic[127X[104X
    [4X[25X>[125X [27Xoriginal_func_id := CAP_JIT_INTERNAL_FUNCTION_ID;;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := 1;;[127X[104X
    [4X[25Xgap>[125X [27X# check that CapJitInlinedFunctionCalls is idempotent[127X[104X
    [4X[25X>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return (function ( )[127X[104X
    [4X[25X>[125X [27X        return (function ( )[127X[104X
    [4X[25X>[125X [27X            return 1; end)( ); end)( ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitInlinedFunctionCalls( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local inline_2_RETURN_VALUE_1, inline_2_inline_3_RETURN_VALUE_1;[128X[104X
    [4X[28X    inline_2_inline_3_RETURN_VALUE_1 := 1;[128X[104X
    [4X[28X    inline_2_RETURN_VALUE_1 := inline_2_inline_3_RETURN_VALUE_1;[128X[104X
    [4X[28X    return inline_2_RETURN_VALUE_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitInlinedFunctionCalls( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    local inline_2_RETURN_VALUE_1, inline_2_inline_3_RETURN_VALUE_1;[128X[104X
    [4X[28X    inline_2_inline_3_RETURN_VALUE_1 := 1;[128X[104X
    [4X[28X    inline_2_RETURN_VALUE_1 := inline_2_inline_3_RETURN_VALUE_1;[128X[104X
    [4X[28X    return inline_2_RETURN_VALUE_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_FUNCTION_ID := original_func_id;;[127X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# test that `CAP_JIT_NOT_RESOLVABLE` does not cause errors when comparing[127X[104X
    [4X[25X>[125X [27X# syntax trees[127X[104X
    [4X[25X>[125X [27XDeclareOperation( "MyNonResolvableOperation", [ ] );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := { } -> MyNonResolvableOperation( );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree2 := StructuralCopy( tree );;[127X[104X
    [4X[25Xgap>[125X [27Xtree2.bindings.BINDING_RETURN_VALUE.funcref.CAP_JIT_NOT_RESOLVABLE := true;;[127X[104X
    [4X[25Xgap>[125X [27XCapJitIsEqualForEnhancedSyntaxTrees( tree, tree2 );[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xfunc := { cat, matrix } -> [[127X[104X
    [4X[25X>[125X [27X    VectorSpaceMorphism( cat, ObjectConstructor( cat, NumberRows( matrix ) ),[127X[104X
    [4X[25X>[125X [27X        matrix, ObjectConstructor( cat, NrCols( matrix ) ) ),[127X[104X
    [4X[25X>[125X [27X    VectorSpaceMorphism( cat, ObjectConstructor( cat, NumberRows( matrix ) ),[127X[104X
    [4X[25X>[125X [27X        matrix, ObjectConstructor( cat, NrCols( matrix ) ) ),[127X[104X
    [4X[25X>[125X [27X];;[127X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27Xcat := MatrixCategory( QQ );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, cat ) );[127X[104X
    [4X[28Xfunction ( cat_1, matrix_1 )[128X[104X
    [4X[28X    local morphism_attr_1_1, morphism_attr_2_1;[128X[104X
    [4X[28X    morphism_attr_2_1 := matrix_1;[128X[104X
    [4X[28X    morphism_attr_1_1 := matrix_1;[128X[104X
    [4X[28X    return [ ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X               ), cat_1, ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X                 ), cat_1, Dimension, NumberRows( morphism_attr_1_1 ) ), [128X[104X
    [4X[28X           ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X                 ), cat_1, Dimension, NumberColumns( morphism_attr_1_1 ) ), [128X[104X
    [4X[28X           UnderlyingMatrix, morphism_attr_1_1 ), [128X[104X
    [4X[28X        ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec([128X[104X
    [4X[28X               ), cat_1, ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X                 ), cat_1, Dimension, NumberRows( morphism_attr_2_1 ) ), [128X[104X
    [4X[28X           ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X                 ), cat_1, Dimension, NumberColumns( morphism_attr_2_1 ) ), [128X[104X
    [4X[28X           UnderlyingMatrix, morphism_attr_2_1 ) ];[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# check that CapJitResolvedGlobalVariables is idempotent[127X[104X
    [4X[25X>[125X [27X[127X[104X
    [4X[25X>[125X [27XMY_GLOBAL_FUNCTION_1 := function ( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    return x; end;;[127X[104X
    [4X[25Xgap>[125X [27XMY_GLOBAL_FUNCTION_2 := function ( x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    return MY_GLOBAL_FUNCTION_1( x ); end;;[127X[104X
    [4X[25Xgap>[125X [27XMY_CAP_CATEGORY_1 := CreateCapCategory( );;[127X[104X
    [4X[25Xgap>[125X [27XMY_CAP_CATEGORY_2 := CreateCapCategory( );;[127X[104X
    [4X[25Xgap>[125X [27XSetUnderlyingCategory( MY_CAP_CATEGORY_1, MY_CAP_CATEGORY_2 );[127X[104X
    [4X[25Xgap>[125X [27XDeclareAttribute( "MyAttribute", IsCapCategory );[127X[104X
    [4X[25Xgap>[125X [27XSetMyAttribute( MY_CAP_CATEGORY_2, MY_GLOBAL_FUNCTION_2 );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  return MY_GLOBAL_FUNCTION_2( MyAttribute([127X[104X
    [4X[25X>[125X [27X        UnderlyingCategory( MY_CAP_CATEGORY_1 )[127X[104X
    [4X[25X>[125X [27X    ) ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitResolvedGlobalVariables( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return function ( x_2 )[128X[104X
    [4X[28X            return function ( x_3 )[128X[104X
    [4X[28X                    return x_3;[128X[104X
    [4X[28X                end( x_2 );[128X[104X
    [4X[28X        end( function ( x_2 )[128X[104X
    [4X[28X            return function ( x_3 )[128X[104X
    [4X[28X                    return x_3;[128X[104X
    [4X[28X                end( x_2 );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := CapJitResolvedGlobalVariables( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return function ( x_2 )[128X[104X
    [4X[28X            return function ( x_3 )[128X[104X
    [4X[28X                    return x_3;[128X[104X
    [4X[28X                end( x_2 );[128X[104X
    [4X[28X        end( function ( x_2 )[128X[104X
    [4X[28X            return function ( x_3 )[128X[104X
    [4X[28X                    return x_3;[128X[104X
    [4X[28X                end( x_2 );[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xtree = tree2;[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XMY_ID_FUNC := x -> x;;[127X[104X
    [4X[25Xgap>[125X [27Xfunc1 := function( x )[127X[104X
    [4X[25X>[125X [27X    if x = 1 then return 1; else return 2; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree1 := ENHANCED_SYNTAX_TREE( func1 );;[127X[104X
    [4X[25Xgap>[125X [27Xtree1.bindings.BINDING_RETURN_VALUE.type = "EXPR_CASE";[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xcoded_func1 := ENHANCED_SYNTAX_TREE_CODE( tree1 );;[127X[104X
    [4X[25Xgap>[125X [27XString( func1 ) = ReplacedString( String( coded_func1 ), "_1", "" );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xtree2 := rec([127X[104X
    [4X[25X>[125X [27X    type := "EXPR_DECLARATIVE_FUNC",[127X[104X
    [4X[25X>[125X [27X    id := 1,[127X[104X
    [4X[25X>[125X [27X    nams := [ "RETURN_VALUE" ],[127X[104X
    [4X[25X>[125X [27X    narg := 0,[127X[104X
    [4X[25X>[125X [27X    nloc := 1,[127X[104X
    [4X[25X>[125X [27X    variadic := false,[127X[104X
    [4X[25X>[125X [27X    bindings := rec([127X[104X
    [4X[25X>[125X [27X        type := "FVAR_BINDING_SEQ",[127X[104X
    [4X[25X>[125X [27X        length := 1,[127X[104X
    [4X[25X>[125X [27X        names := [ "RETURN_VALUE" ],[127X[104X
    [4X[25X>[125X [27X        BINDING_RETURN_VALUE := rec([127X[104X
    [4X[25X>[125X [27X            type := "EXPR_FUNCCALL",[127X[104X
    [4X[25X>[125X [27X            funcref := rec([127X[104X
    [4X[25X>[125X [27X                type := "EXPR_REF_GVAR",[127X[104X
    [4X[25X>[125X [27X                gvar := "MY_ID_FUNC",[127X[104X
    [4X[25X>[125X [27X            ),[127X[104X
    [4X[25X>[125X [27X            args := AsSyntaxTreeList( [[127X[104X
    [4X[25X>[125X [27X                rec([127X[104X
    [4X[25X>[125X [27X                    type := "EXPR_CASE",[127X[104X
    [4X[25X>[125X [27X                    branches := AsSyntaxTreeList( [[127X[104X
    [4X[25X>[125X [27X                        rec([127X[104X
    [4X[25X>[125X [27X                            type := "CASE_BRANCH",[127X[104X
    [4X[25X>[125X [27X                            condition := rec([127X[104X
    [4X[25X>[125X [27X                                type := "EXPR_FALSE",[127X[104X
    [4X[25X>[125X [27X                            ),[127X[104X
    [4X[25X>[125X [27X                            value := rec([127X[104X
    [4X[25X>[125X [27X                                type := "EXPR_INT",[127X[104X
    [4X[25X>[125X [27X                                value := 1,[127X[104X
    [4X[25X>[125X [27X                            ),[127X[104X
    [4X[25X>[125X [27X                        ),[127X[104X
    [4X[25X>[125X [27X                        rec([127X[104X
    [4X[25X>[125X [27X                            type := "CASE_BRANCH",[127X[104X
    [4X[25X>[125X [27X                            condition := rec([127X[104X
    [4X[25X>[125X [27X                                type := "EXPR_TRUE",[127X[104X
    [4X[25X>[125X [27X                            ),[127X[104X
    [4X[25X>[125X [27X                            value := rec([127X[104X
    [4X[25X>[125X [27X                                type := "EXPR_INT",[127X[104X
    [4X[25X>[125X [27X                                value := 2,[127X[104X
    [4X[25X>[125X [27X                            ),[127X[104X
    [4X[25X>[125X [27X                        ),[127X[104X
    [4X[25X>[125X [27X                    ] ),[127X[104X
    [4X[25X>[125X [27X                ),[127X[104X
    [4X[25X>[125X [27X            ] ),[127X[104X
    [4X[25X>[125X [27X        ),[127X[104X
    [4X[25X>[125X [27X    ),[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xcoded_func2 := ENHANCED_SYNTAX_TREE_CODE( tree2 );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( coded_func2 );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return MY_ID_FUNC( function (  )[128X[104X
    [4X[28X              if false then[128X[104X
    [4X[28X                  return 1;[128X[104X
    [4X[28X              else[128X[104X
    [4X[28X                  return 2;[128X[104X
    [4X[28X              fi;[128X[104X
    [4X[28X              return;[128X[104X
    [4X[28X          end(  ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xcoded_func2();[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27X# we have to work hard to not write semicolons so AutoDoc[127X[104X
    [4X[25X>[125X [27X# does not begin a new statement[127X[104X
    [4X[25X>[125X [27Xfunc3 := EvalString( ReplacedString( """function( x )[127X[104X
    [4X[25X>[125X [27X  local my_func, inner_func@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    my_func := MY_ID_FUNC( x -> x )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    inner_func := function( )[127X[104X
    [4X[25X>[125X [27X      local y@[127X[104X
    [4X[25X>[125X [27X        if x then[127X[104X
    [4X[25X>[125X [27X            return 1@[127X[104X
    [4X[25X>[125X [27X        else[127X[104X
    [4X[25X>[125X [27X            y := 2@[127X[104X
    [4X[25X>[125X [27X            return y@[127X[104X
    [4X[25X>[125X [27X        fi@[127X[104X
    [4X[25X>[125X [27X    end@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    return my_func( inner_func( ) )@[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27Xend""", "@", ";" ) );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func3 := CapJitCompiledFunction( func3 );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func3 );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    local deduped_1_1;[128X[104X
    [4X[28X    deduped_1_1 := MY_ID_FUNC( function ( x_2 )[128X[104X
    [4X[28X            return x_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28X    if x_1 then[128X[104X
    [4X[28X        return deduped_1_1( 1 );[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return deduped_1_1( 2 );[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc4 := function( x )[127X[104X
    [4X[25X>[125X [27X  local y; if x then return 1; else return 1; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func4 := CapJitCompiledFunction( func4 );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( compiled_func4 );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  return List( [ 1, 2 ], x -> x ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return [ function ( x_2 )[128X[104X
    [4X[28X                return x_2;[128X[104X
    [4X[28X            end( 1 ), function ( x_2 )[128X[104X
    [4X[28X                return x_2;[128X[104X
    [4X[28X            end( 2 ) ];[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( L1, L2 )[127X[104X
    [4X[25X>[125X [27X  return List( Concatenation( L1, L2 ), x -> x ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( L1_1, L2_1 )[128X[104X
    [4X[28X    return Concatenation( List( L1_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end ), List( L2_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end ) );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  return Concatenation( [ [ 1, 2, 3, 4 ] ] ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return [ 1, 2, 3, 4 ];[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  return Concatenation( [ [ 1, 2 ], [ 3, 4 ] ] ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return [ 1, 2, 3, 4 ];[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  return Concatenation( [ 1, 2 ], [ 3, 4 ] ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction (  )[128X[104X
    [4X[28X    return [ 1, 2, 3, 4 ];[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( my_func )[127X[104X
    [4X[25X>[125X [27X  return CallFuncList( my_func, [ 1, 2 ] ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( my_func_1 )[128X[104X
    [4X[28X    return my_func_1( 1, 2 );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( x )[127X[104X
    [4X[25X>[125X [27X  if 1 = 2 then return 1; elif x = x then return 2; else return 3; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    if false then[128X[104X
    [4X[28X        return 1;[128X[104X
    [4X[28X    elif true then[128X[104X
    [4X[28X        return 2;[128X[104X
    [4X[28X    else[128X[104X
    [4X[28X        return 3;[128X[104X
    [4X[28X    fi;[128X[104X
    [4X[28X    return;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( x )[127X[104X
    [4X[25X>[125X [27X  return Length( [ 1, 2, 3 ] ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return 3;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( x )[127X[104X
    [4X[25X>[125X [27X  return [ 1 .. 3 ]; end;;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitAppliedLogic( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return [ 1, 2, 3 ];[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "CompilerForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# example testing needed_packages[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "name" ],[127X[104X
    [4X[25X>[125X [27X    variable_filters := [ "THIS_SHOULD_NOT_BE_PARSED" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "THIS_SHOULD_NOT_BE_PARSED_TOO",[127X[104X
    [4X[25X>[125X [27X    dst_template := "THIS_SHOULD_NOT_BE_PARSED_EITHER",[127X[104X
    [4X[25X>[125X [27X    needed_packages := [ [ "NON_EXISTING_PACKAGE", ">= 9999" ] ],[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XAdd( CAP_JIT_LOGIC_TEMPLATES, template );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( x -> x ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return x_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XIsIdenticalObj( Remove( CAP_JIT_LOGIC_TEMPLATES ), template );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xapplied_logic_template_to_func :=[127X[104X
    [4X[25X>[125X [27X    { func, template, type_signature } ->[127X[104X
    [4X[25X>[125X [27X        ENHANCED_SYNTAX_TREE_CODE([127X[104X
    [4X[25X>[125X [27X            CAP_JIT_INTERNAL_APPLIED_LOGIC_TEMPLATES([127X[104X
    [4X[25X>[125X [27X                CapJitInferredDataTypes([127X[104X
    [4X[25X>[125X [27X                    ENHANCED_SYNTAX_TREE([127X[104X
    [4X[25X>[125X [27X                        func :[127X[104X
    [4X[25X>[125X [27X                        type_signature := type_signature[127X[104X
    [4X[25X>[125X [27X                    )[127X[104X
    [4X[25X>[125X [27X                ),[127X[104X
    [4X[25X>[125X [27X                [ template ][127X[104X
    [4X[25X>[125X [27X            )[127X[104X
    [4X[25X>[125X [27X        );;[127X[104X
    [4X[25Xgap>[125X [27X# some general example[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "variable" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "x -> x + variable + x - x",[127X[104X
    [4X[25X>[125X [27X    dst_template := "x -> x + variable + 0",[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( a )[127X[104X
    [4X[25X>[125X [27X    return b -> b + ( 2 * b + a ) + b - b; end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, fail ) );[127X[104X
    [4X[28Xfunction ( a_1 )[128X[104X
    [4X[28X    return function ( b_2 )[128X[104X
    [4X[28X          return b_2 + (2 * b_2 + a_1) + 0;[128X[104X
    [4X[28X      end;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# example using EXPR_CASE[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "val1", "val2" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "CAP_JIT_INTERNAL_EXPR_CASE( 1 <> 1, val1, true, val2 )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "val2",[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X    if 1 <> 1 then return 1; else return 2; fi; end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, fail ) );[127X[104X
    [4X[28Xfunction ( )[128X[104X
    [4X[28X    return 2;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that functions in variables can match[127X[104X
    [4X[25X>[125X [27X# and test variable_filters (strings and filters)[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "L1", "L2", "func" ],[127X[104X
    [4X[25X>[125X [27X    variable_filters := [ "IsList", IsList, IsFunction ],[127X[104X
    [4X[25X>[125X [27X    src_template := "Concatenation( [ List( L1, func ), List( L2, func ) ] )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "List( Concatenation( [ L1, L2 ] ), func )",[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := { L1, L2 } ->[127X[104X
    [4X[25X>[125X [27X    Concatenation( [ List( L1, x -> x ), List( L2, x -> x ) ] );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func([127X[104X
    [4X[25X>[125X [27X    func,[127X[104X
    [4X[25X>[125X [27X    template,[127X[104X
    [4X[25X>[125X [27X    [[127X[104X
    [4X[25X>[125X [27X        [[127X[104X
    [4X[25X>[125X [27X            rec( filter := IsList, element_type := rec( filter := IsInt ) ),[127X[104X
    [4X[25X>[125X [27X            rec( filter := IsList, element_type := rec( filter := IsInt ) ),[127X[104X
    [4X[25X>[125X [27X        ],[127X[104X
    [4X[25X>[125X [27X        fail,[127X[104X
    [4X[25X>[125X [27X    ][127X[104X
    [4X[25X>[125X [27X) );[127X[104X
    [4X[28Xfunction ( L1_1, L2_1 )[128X[104X
    [4X[28X    return List( Concatenation( [ L1_1, L2_1 ] ), function ( x_2 )[128X[104X
    [4X[28X            return x_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that template is not executed if data types cannot be determined[127X[104X
    [4X[25X>[125X [27XDisplay( applied_logic_template_to_func( func, template, fail ) );[127X[104X
    [4X[28Xfunction ( L1_1, L2_1 )[128X[104X
    [4X[28X    return Concatenation( [ List( L1_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end ), List( L2_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end ) ] );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that template is only applied if filters match[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "value" ],[127X[104X
    [4X[25X>[125X [27X    variable_filters := [ IsInt ],[127X[104X
    [4X[25X>[125X [27X    src_template := "Sum( [ value ] )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "value",[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := { x } -> Sum( [ x ] );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func([127X[104X
    [4X[25X>[125X [27X    func,[127X[104X
    [4X[25X>[125X [27X    template,[127X[104X
    [4X[25X>[125X [27X    [[127X[104X
    [4X[25X>[125X [27X        [[127X[104X
    [4X[25X>[125X [27X            rec( filter := IsInt ),[127X[104X
    [4X[25X>[125X [27X        ],[127X[104X
    [4X[25X>[125X [27X        fail,[127X[104X
    [4X[25X>[125X [27X    ][127X[104X
    [4X[25X>[125X [27X) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return x_1;[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func([127X[104X
    [4X[25X>[125X [27X    func,[127X[104X
    [4X[25X>[125X [27X    template,[127X[104X
    [4X[25X>[125X [27X    [[127X[104X
    [4X[25X>[125X [27X        [[127X[104X
    [4X[25X>[125X [27X            rec( filter := IsFloat ),[127X[104X
    [4X[25X>[125X [27X        ],[127X[104X
    [4X[25X>[125X [27X        fail,[127X[104X
    [4X[25X>[125X [27X    ][127X[104X
    [4X[25X>[125X [27X) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return Sum( [ x_1 ] );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that functions can be used multiple times in dst_template[127X[104X
    [4X[25X>[125X [27X# add a nonsense template[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "list", "value" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "List( list, l -> value )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "Sum( list, l -> value ) + Sum( list, l -> value )",[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( list )[127X[104X
    [4X[25X>[125X [27X    return List( list, x -> x ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, fail ) );[127X[104X
    [4X[28Xfunction ( list_1 )[128X[104X
    [4X[28X    return Sum( list_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end ) + Sum( list_1, function ( x_2 )[128X[104X
    [4X[28X              return x_2;[128X[104X
    [4X[28X          end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( list )[127X[104X
    [4X[25X>[125X [27X    return List( list, x -> (y -> y) ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, fail ) );[127X[104X
    [4X[28Xfunction ( list_1 )[128X[104X
    [4X[28X    return Sum( list_1, function ( x_2 )[128X[104X
    [4X[28X              return function ( y_3 )[128X[104X
    [4X[28X                    return y_3;[128X[104X
    [4X[28X                end;[128X[104X
    [4X[28X          end ) + Sum( list_1, function ( x_2 )[128X[104X
    [4X[28X              return function ( y_3 )[128X[104X
    [4X[28X                    return y_3;[128X[104X
    [4X[28X                end;[128X[104X
    [4X[28X          end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that functions with assignments to local variables do not match[127X[104X
    [4X[25X>[125X [27X# logic templates without assignments to local variables[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "value" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "List( [ 1 ], l -> value )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "(l -> value)(1)",[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( x )[127X[104X
    [4X[25X>[125X [27X    return List( [ 1 ], function ( y )[127X[104X
    [4X[25X>[125X [27X        local r; r := x; return r; end ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, fail ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return List( [ 1 ], function ( y_2 )[128X[104X
    [4X[28X            local r_2;[128X[104X
    [4X[28X            r_2 := x_1;[128X[104X
    [4X[28X            return r_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27X# check that values are pulled out iff[127X[104X
    [4X[25X>[125X [27X# they are independent of local variables[127X[104X
    [4X[25X>[125X [27Xtemplate := rec([127X[104X
    [4X[25X>[125X [27X    variable_names := [ "list", "value" ],[127X[104X
    [4X[25X>[125X [27X    src_template := "List( list, l -> value * l )",[127X[104X
    [4X[25X>[125X [27X    dst_template := "value * List( list, l -> l )",[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XCAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );[127X[104X
    [4X[25Xgap>[125X [27Xfunc := L -> List( L, l -> l * l );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, fail ) );[127X[104X
    [4X[28Xfunction ( L_1 )[128X[104X
    [4X[28X    return List( L_1, function ( l_2 )[128X[104X
    [4X[28X            return l_2 * l_2;[128X[104X
    [4X[28X        end );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xfunc := L -> List( L, l -> 2 * l );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( applied_logic_template_to_func( func, template, fail ) );[127X[104X
    [4X[28Xfunction ( L_1 )[128X[104X
    [4X[28X    return 2 * List( L_1, function ( l_2 )[128X[104X
    [4X[28X              return l_2;[128X[104X
    [4X[28X          end );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc := x -> x[1,1];;[127X[104X
    [4X[25Xgap>[125X [27Xtree := ENHANCED_SYNTAX_TREE( func );;[127X[104X
    [4X[25Xgap>[125X [27Xtree := CapJitResolvedGlobalVariables( tree );;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( ENHANCED_SYNTAX_TREE_CODE( tree ) );[127X[104X
    [4X[28Xfunction ( x_1 )[128X[104X
    [4X[28X    return MatElm( x_1, 1, 1 );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "FreydCategoriesForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationalsInSingular( );;[127X[104X
    [4X[25Xgap>[125X [27XQQxy := QQ * "x,y";;[127X[104X
    [4X[25Xgap>[125X [27XEEE := KoszulDualRing( QQxy * "a,b" );;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_CategoryOfColumns := function( homalg_ring, name )[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    CapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X        homalg_ring -> CategoryOfColumnsAsOppositeOfCategoryOfRows([127X[104X
    [4X[25X>[125X [27X            homalg_ring[127X[104X
    [4X[25X>[125X [27X        ),[127X[104X
    [4X[25X>[125X [27X        [ homalg_ring ],[127X[104X
    [4X[25X>[125X [27X        "FreydCategoriesForCAP",[127X[104X
    [4X[25X>[125X [27X        Concatenation([127X[104X
    [4X[25X>[125X [27X            "CategoryOfColumnsAsOppositeOfCategoryOfRowsOf",[127X[104X
    [4X[25X>[125X [27X            name,[127X[104X
    [4X[25X>[125X [27X            "Precompiled"[127X[104X
    [4X[25X>[125X [27X        ) :[127X[104X
    [4X[25X>[125X [27X        operations := "primitive"[127X[104X
    [4X[25X>[125X [27X    ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_CategoryOfColumns( QQ, "Field" );;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_CategoryOfColumns( QQxy, "CommutativeRing" );;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_CategoryOfColumns( EEE, "ArbitraryRing" );;[127X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "FreydCategoriesForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XReadPackage( "FreydCategoriesForCAP",[127X[104X
    [4X[25X>[125X [27X    "gap/CategoryOfRowsAsAdditiveClosureOfRingAsCategory_CompilerLogic.gi");[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27X# We only compile one very special case:[127X[104X
    [4X[25X>[125X [27X# The homomorphism structure for homalg exterior rings over fields.[127X[104X
    [4X[25X>[125X [27X[127X[104X
    [4X[25X>[125X [27XQQ := HomalgFieldOfRationalsInSingular( );;[127X[104X
    [4X[25Xgap>[125X [27XQQxy := QQ * "x,y";;[127X[104X
    [4X[25Xgap>[125X [27XEEE := KoszulDualRing( QQxy );;[127X[104X
    [4X[25Xgap>[125X [27Xcategory_constructor :=[127X[104X
    [4X[25X>[125X [27X    homalg_ring -> CategoryOfRowsAsAdditiveClosureOfRingAsCategory([127X[104X
    [4X[25X>[125X [27X        homalg_ring[127X[104X
    [4X[25X>[125X [27X    );;[127X[104X
    [4X[25Xgap>[125X [27Xgiven_arguments := [ EEE ];;[127X[104X
    [4X[25Xgap>[125X [27Xpackage_name := "FreydCategoriesForCAP";;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_category_name := Concatenation([127X[104X
    [4X[25X>[125X [27X    "CategoryOfRowsAsAdditiveClosureOfRingAsCategoryOf",[127X[104X
    [4X[25X>[125X [27X    "HomalgExteriorRingOverFieldPrecompiled"[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xoperations := [[127X[104X
    [4X[25X>[125X [27X    "DistinguishedObjectOfHomomorphismStructure",[127X[104X
    [4X[25X>[125X [27X    "HomomorphismStructureOnObjects",[127X[104X
    [4X[25X>[125X [27X    "HomomorphismStructureOnMorphismsWithGivenObjects",[127X[104X
    [4X[25X>[125X [27X    Concatenation([127X[104X
    [4X[25X>[125X [27X        "InterpretMorphismAsMorphismFromDistinguishedObject",[127X[104X
    [4X[25X>[125X [27X        "ToHomomorphismStructureWithGivenObjects"[127X[104X
    [4X[25X>[125X [27X    ),[127X[104X
    [4X[25X>[125X [27X    Concatenation([127X[104X
    [4X[25X>[125X [27X        "InterpretMorphismFromDistinguishedObject",[127X[104X
    [4X[25X>[125X [27X        "ToHomomorphismStructureAsMorphism"[127X[104X
    [4X[25X>[125X [27X    ),[127X[104X
    [4X[25X>[125X [27X];;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X    category_constructor,[127X[104X
    [4X[25X>[125X [27X    given_arguments,[127X[104X
    [4X[25X>[125X [27X    package_name,[127X[104X
    [4X[25X>[125X [27X    compiled_category_name :[127X[104X
    [4X[25X>[125X [27X    operations := operations[127X[104X
    [4X[25X>[125X [27X);[127X[104X
    [4X[25Xgap>[125X [27X# check that the compiled code is loaded automatically[127X[104X
    [4X[25X>[125X [27Xcat := CategoryOfRows( EEE );;[127X[104X
    [4X[25Xgap>[125X [27XCanCompute( cat, "HomomorphismStructureOnMorphismsWithGivenObjects" );[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "ModulePresentationsForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationalsInSingular( );;[127X[104X
    [4X[25Xgap>[125X [27XQQxy := QQ * "x,y";;[127X[104X
    [4X[25Xgap>[125X [27XEEE := KoszulDualRing( QQxy * "a,b" );;[127X[104X
    [4X[25Xgap>[125X [27X# CAUTION: when adding new operations make sure that they are compatible[127X[104X
    [4X[25X>[125X [27X# with the ones added manually in `ADD_FUNCTIONS_FOR_LEFT/RIGHT_PRESENTATION`.[127X[104X
    [4X[25X>[125X [27Xoperations_for_arbitrary_ring := [[127X[104X
    [4X[25X>[125X [27X    "AdditionForMorphisms",[127X[104X
    [4X[25X>[125X [27X    "AdditiveInverseForMorphisms",[127X[104X
    [4X[25X>[125X [27X    #"AssociatorLeftToRightWithGivenTensorProducts",[127X[104X
    [4X[25X>[125X [27X    #"AssociatorRightToLeftWithGivenTensorProducts",[127X[104X
    [4X[25X>[125X [27X    #"BraidingWithGivenTensorProducts",[127X[104X
    [4X[25X>[125X [27X    #"CoevaluationMorphismWithGivenRange",[127X[104X
    [4X[25X>[125X [27X    "CokernelColiftWithGivenCokernelObject",[127X[104X
    [4X[25X>[125X [27X    "CokernelProjection",[127X[104X
    [4X[25X>[125X [27X    #"Colift",[127X[104X
    [4X[25X>[125X [27X    #"ColiftOrFail",[127X[104X
    [4X[25X>[125X [27X    "DirectSum",[127X[104X
    [4X[25X>[125X [27X    "EpimorphismFromSomeProjectiveObject",[127X[104X
    [4X[25X>[125X [27X    #"EvaluationMorphismWithGivenSource",[127X[104X
    [4X[25X>[125X [27X    "IdentityMorphism",[127X[104X
    [4X[25X>[125X [27X    "InjectionOfCofactorOfDirectSumWithGivenDirectSum",[127X[104X
    [4X[25X>[125X [27X    #"InternalHomOnMorphismsWithGivenInternalHoms",[127X[104X
    [4X[25X>[125X [27X    #"InternalHomOnObjects",[127X[104X
    [4X[25X>[125X [27X    #"IsColiftable",[127X[104X
    [4X[25X>[125X [27X    "IsCongruentForMorphisms",[127X[104X
    [4X[25X>[125X [27X    "IsEqualForMorphisms",[127X[104X
    [4X[25X>[125X [27X    #"IsEqualForObjects",[127X[104X
    [4X[25X>[125X [27X    #"IsLiftable",[127X[104X
    [4X[25X>[125X [27X    #"IsWellDefinedForMorphisms",[127X[104X
    [4X[25X>[125X [27X    #"IsWellDefinedForObjects",[127X[104X
    [4X[25X>[125X [27X    "IsZeroForMorphisms",[127X[104X
    [4X[25X>[125X [27X    #"KernelEmbedding",[127X[104X
    [4X[25X>[125X [27X    #"LeftUnitorWithGivenTensorProduct",[127X[104X
    [4X[25X>[125X [27X    #"Lift",[127X[104X
    [4X[25X>[125X [27X    #"LiftAlongMonomorphism",[127X[104X
    [4X[25X>[125X [27X    #"LiftOrFail",[127X[104X
    [4X[25X>[125X [27X    #"MultiplyWithElementOfCommutativeRingForMorphisms",[127X[104X
    [4X[25X>[125X [27X    #"PreCompose",[127X[104X
    [4X[25X>[125X [27X    "ProjectionInFactorOfDirectSumWithGivenDirectSum",[127X[104X
    [4X[25X>[125X [27X    #"RightUnitorWithGivenTensorProduct",[127X[104X
    [4X[25X>[125X [27X    #"TensorProductOnMorphismsWithGivenTensorProducts",[127X[104X
    [4X[25X>[125X [27X    #"TensorProductOnObjects",[127X[104X
    [4X[25X>[125X [27X    #"TensorUnit",[127X[104X
    [4X[25X>[125X [27X    "UniversalMorphismFromDirectSumWithGivenDirectSum",[127X[104X
    [4X[25X>[125X [27X    "UniversalMorphismFromZeroObjectWithGivenZeroObject",[127X[104X
    [4X[25X>[125X [27X    "UniversalMorphismIntoDirectSumWithGivenDirectSum",[127X[104X
    [4X[25X>[125X [27X    "UniversalMorphismIntoZeroObjectWithGivenZeroObject",[127X[104X
    [4X[25X>[125X [27X    "ZeroMorphism",[127X[104X
    [4X[25X>[125X [27X    "ZeroObject" [127X[104X
    [4X[25X>[125X [27X];;[127X[104X
    [4X[25Xgap>[125X [27Xoperations_for_commutative_ring := Concatenation([127X[104X
    [4X[25X>[125X [27X    operations_for_arbitrary_ring,[127X[104X
    [4X[25X>[125X [27X    [ "MultiplyWithElementOfCommutativeRingForMorphisms" ][127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_LeftPresentations := function( ring, name, operations )[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    CapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X        ring -> LeftPresentationsAsFreydCategoryOfCategoryOfRows( ring ),[127X[104X
    [4X[25X>[125X [27X        [ ring ],[127X[104X
    [4X[25X>[125X [27X        "ModulePresentationsForCAP",[127X[104X
    [4X[25X>[125X [27X        Concatenation([127X[104X
    [4X[25X>[125X [27X            "LeftPresentationsAsFreydCategoryOfCategoryOfRowsOf",[127X[104X
    [4X[25X>[125X [27X            name,[127X[104X
    [4X[25X>[125X [27X            "Precompiled"[127X[104X
    [4X[25X>[125X [27X        ) :[127X[104X
    [4X[25X>[125X [27X        operations := operations[127X[104X
    [4X[25X>[125X [27X    ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_LeftPresentations([127X[104X
    [4X[25X>[125X [27X    QQ, "Field", operations_for_commutative_ring[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_LeftPresentations([127X[104X
    [4X[25X>[125X [27X    QQxy, "CommutativeRing", operations_for_commutative_ring[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_LeftPresentations([127X[104X
    [4X[25X>[125X [27X    EEE, "ArbitraryRing", operations_for_arbitrary_ring[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_RightPresentations := function( ring, name, operations )[127X[104X
    [4X[25X>[125X [27X    [127X[104X
    [4X[25X>[125X [27X    CapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X        ring -> RightPresentationsAsFreydCategoryOfCategoryOfColumns( ring ),[127X[104X
    [4X[25X>[125X [27X        [ ring ],[127X[104X
    [4X[25X>[125X [27X        "ModulePresentationsForCAP",[127X[104X
    [4X[25X>[125X [27X        Concatenation([127X[104X
    [4X[25X>[125X [27X            "RightPresentationsAsFreydCategoryOfCategoryOfColumnsOf",[127X[104X
    [4X[25X>[125X [27X            name,[127X[104X
    [4X[25X>[125X [27X            "Precompiled"[127X[104X
    [4X[25X>[125X [27X        ) :[127X[104X
    [4X[25X>[125X [27X        operations := operations[127X[104X
    [4X[25X>[125X [27X    ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_RightPresentations([127X[104X
    [4X[25X>[125X [27X    QQ, "Field", operations_for_commutative_ring[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_RightPresentations([127X[104X
    [4X[25X>[125X [27X    QQxy, "CommutativeRing", operations_for_commutative_ring[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27Xprecompile_RightPresentations([127X[104X
    [4X[25X>[125X [27X    EEE, "ArbitraryRing", operations_for_arbitrary_ring[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27X# check that the compiled code is loaded automatically[127X[104X
    [4X[25X>[125X [27X# for this, we use the name of the argument of `ZeroObject`:[127X[104X
    [4X[25X>[125X [27X# for non-compiled code it is "cat", while for compiled code it is "cat_1"[127X[104X
    [4X[25X>[125X [27X[127X[104X
    [4X[25X>[125X [27Xcat := LeftPresentations( QQ );;[127X[104X
    [4X[25Xgap>[125X [27XNamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1][127X[104X
    [4X[25X>[125X [27X    = "cat_1";[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xcat := LeftPresentations( QQxy );;[127X[104X
    [4X[25Xgap>[125X [27XNamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1][127X[104X
    [4X[25X>[125X [27X    = "cat_1";[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xcat := LeftPresentations( EEE );;[127X[104X
    [4X[25Xgap>[125X [27XNamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1][127X[104X
    [4X[25X>[125X [27X    = "cat_1";[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xcat := RightPresentations( QQ );;[127X[104X
    [4X[25Xgap>[125X [27XNamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1][127X[104X
    [4X[25X>[125X [27X    = "cat_1";[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xcat := RightPresentations( QQxy );;[127X[104X
    [4X[25Xgap>[125X [27XNamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1][127X[104X
    [4X[25X>[125X [27X    = "cat_1";[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27Xcat := RightPresentations( EEE );;[127X[104X
    [4X[25Xgap>[125X [27XNamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1][127X[104X
    [4X[25X>[125X [27X    = "cat_1";[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27X# be careful not to use `MatrixCategory` because attributes are not supported[127X[104X
    [4X[25X>[125X [27Xcategory_constructor := function( field )[127X[104X
    [4X[25X>[125X [27X    return Opposite([127X[104X
    [4X[25X>[125X [27X        MATRIX_CATEGORY([127X[104X
    [4X[25X>[125X [27X            field :[127X[104X
    [4X[25X>[125X [27X            no_precompiled_code := true, FinalizeCategory := true[127X[104X
    [4X[25X>[125X [27X        ) :[127X[104X
    [4X[25X>[125X [27X        only_primitive_operations := true[127X[104X
    [4X[25X>[125X [27X    ); end;;[127X[104X
    [4X[25Xgap>[125X [27Xgiven_arguments := [ QQ ];;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_category_name := "OppositeOfMatrixCategoryPrecompiled";;[127X[104X
    [4X[25Xgap>[125X [27Xpackage_name := "LinearAlgebraForCAP";;[127X[104X
    [4X[25Xgap>[125X [27XCapJitPrecompileCategoryAndCompareResult([127X[104X
    [4X[25X>[125X [27X    category_constructor,[127X[104X
    [4X[25X>[125X [27X    given_arguments,[127X[104X
    [4X[25X>[125X [27X    package_name,[127X[104X
    [4X[25X>[125X [27X    compiled_category_name :[127X[104X
    [4X[25X>[125X [27X    operations := "primitive"[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XReadPackage([127X[104X
    [4X[25X>[125X [27X    "LinearAlgebraForCAP",[127X[104X
    [4X[25X>[125X [27X    "gap/precompiled_categories/OppositeOfMatrixCategoryPrecompiled.gi"[127X[104X
    [4X[25X>[125X [27X);;[127X[104X
    [4X[25Xgap>[125X [27XOppositeOfMatrixCategoryPrecompiled( QQ );[127X[104X
    [4X[28XOpposite of Category of matrices over Q[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage( "LinearAlgebraForCAP", false );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XQ := HomalgFieldOfRationals( );;[127X[104X
    [4X[25Xgap>[125X [27Xvec := MATRIX_CATEGORY( Q : no_precompiled_code );;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := cat -> ZeroObjectFunctorial( cat );;[127X[104X
    [4X[25Xgap>[125X [27XStopCompilationAtCategory( vec );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, vec ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    return ZeroObjectFunctorial( cat_1 );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XContinueCompilationAtCategory( vec );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, vec ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    local morphism_attr_1_1, deduped_2_1;[128X[104X
    [4X[28X    deduped_2_1 := ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Dimension, 0 );[128X[104X
    [4X[28X    morphism_attr_1_1 [128X[104X
    [4X[28X     := HomalgZeroMatrix( 0, 0, UnderlyingRing( cat_1 ) );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes[128X[104X
    [4X[28X        ( rec([128X[104X
    [4X[28X           ), cat_1, deduped_2_1, deduped_2_1, UnderlyingMatrix, [128X[104X
    [4X[28X       morphism_attr_1_1 );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27Xvec := MATRIX_CATEGORY( Q : no_precompiled_code );;[127X[104X
    [4X[25Xgap>[125X [27XStopCompilationAtPrimitivelyInstalledOperationsOfCategory( vec );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, vec ) );[127X[104X
    [4X[28XWARNING: Could not find declaration of ZeroObject (current input: \[128X[104X
    [4X[28X[ <Category "IsMatrixCategory"> ])[128X[104X
    [4X[28XWARNING: Could not find declaration of ZeroObject (current input: \[128X[104X
    [4X[28X[ <Category "IsMatrixCategory"> ])[128X[104X
    [4X[28XWARNING: Could not find declaration of ZeroObject (current input: \[128X[104X
    [4X[28X[ <Category "IsMatrixCategory"> ])[128X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    local deduped_1_1;[128X[104X
    [4X[28X    deduped_1_1 := ZeroObject( cat_1 );[128X[104X
    [4X[28X    return ZeroMorphism( cat_1, deduped_1_1, deduped_1_1 );[128X[104X
    [4X[28Xend[128X[104X
    [4X[25Xgap>[125X [27XContinueCompilationAtPrimitivelyInstalledOperationsOfCategory( vec );[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func, vec ) );[127X[104X
    [4X[28Xfunction ( cat_1 )[128X[104X
    [4X[28X    local morphism_attr_1_1, deduped_2_1;[128X[104X
    [4X[28X    deduped_2_1 := ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Dimension, 0 );[128X[104X
    [4X[28X    morphism_attr_1_1 [128X[104X
    [4X[28X     := HomalgZeroMatrix( 0, 0, UnderlyingRing( cat_1 ) );[128X[104X
    [4X[28X    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes[128X[104X
    [4X[28X        ( rec([128X[104X
    [4X[28X           ), cat_1, deduped_2_1, deduped_2_1, UnderlyingMatrix, [128X[104X
    [4X[28X       morphism_attr_1_1 );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQ := HomalgFieldOfRationals();;[127X[104X
    [4X[25Xgap>[125X [27Xvec := MATRIX_CATEGORY( Q );;[127X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( cat, x )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    return ZeroObject( cat ); end;;[127X[104X
    [4X[25Xgap>[125X [27X# make sure that ZeroObject( cat ) is not resolved to a global variable[127X[104X
    [4X[25X>[125X [27XDisplay( CapJitCompiledFunction( { cat, x } -> func( cat, x ), vec ) );[127X[104X
    [4X[28Xfunction ( cat_1, x_1 )[128X[104X
    [4X[28X    return ObjectifyObjectForCAPWithAttributes( rec([128X[104X
    [4X[28X           ), cat_1, Dimension, 0 );[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc := function ( )[127X[104X
    [4X[25X>[125X [27X  local x; x := { args... } -> 1; return x( ); end;;[127X[104X
    [4X[25Xgap>[125X [27XDisplay( CapJitCompiledFunction( func ) );[127X[104X
    [4X[28Xfunction ( )[128X[104X
    [4X[28X    return 1;[128X[104X
    [4X[28Xend[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc1 := function( x, y )[127X[104X
    [4X[25X>[125X [27X    #% CAP_JIT_RESOLVE_FUNCTION[127X[104X
    [4X[25X>[125X [27X    return x; end;;[127X[104X
    [4X[25Xgap>[125X [27Xfunc2 := function( )[127X[104X
    [4X[25X>[125X [27X  local var; var := 1; var := func1( 2, var ); return var; end;;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func := CapJitCompiledFunction( func2 );;[127X[104X
    [4X[25Xgap>[125X [27Xcompiled_func();[127X[104X
    [4X[28X2[128X[104X
  [4X[32X[104X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfunc := function( )[127X[104X
    [4X[25X>[125X [27X  local id; id := y -> y; return [ id, id ]; end;;[127X[104X
    [4X[25Xgap>[125X [27X# we are not interested in the output, but only that this does not throw[127X[104X
    [4X[25X>[125X [27X# an error due to some function id being used multiple times[127X[104X
    [4X[25X>[125X [27XCapJitCompiledFunction( func );;[127X[104X
  [4X[32X[104X
  
