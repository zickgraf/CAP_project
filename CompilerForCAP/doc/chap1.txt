  
  [1X1 [33X[0;0YUsing the compiler[133X[101X
  
  
  [1X1.1 [33X[0;0YTerminology[133X[101X
  
  [33X[0;0YThe compiler was started as a just-in-time compiler, that is, it needed some
  arguments  to  infer  types of variables. Although the compiler now supports
  precompilation  and  type  signatures can be explicitly given, it still is a
  just-in-time  compiler  in  the following sense: Only methods for operations
  getting  a  CAP category as the first argument can be found by the compiler,
  and an instance of a CAP category is needed for method selection.[133X
  
  [33X[0;0YThe compiler uses GAP's syntax trees for optimizing functions. The term [13Xtree[113X
  always refers to the syntax tree of the function to be compiled. Note that a
  node  of  the  tree  always  knows its children, so technically it is also a
  tree.  That  is,  the terms [13Xtree[113X, [13Xsubtree[113X, and [13Xnode[113X technically describe the
  same thing but we use them for different emphases.[133X
  
  [33X[0;0YWe often replace a node in the tree by another tree representing the "value"
  of the original node. Examples:[133X
  
  [30X    [33X[0;6YReplace  a  global  variable  referencing  an  integer, a string, or a
        boolean by EXPR_INT, EXPR_STRING, EXPR_TRUE or EXPR_FALSE.[133X
  
  [30X    [33X[0;6YReplace  a  global variable referencing a plain function by the syntax
        tree of this function.[133X
  
  [30X    [33X[0;6YReplace  a  record  access  of  a global function by the value of this
        record access.[133X
  
  [30X    [33X[0;6YReplace an operation by a concrete method.[133X
  
  [33X[0;0YWe  call  this [13Xresolving[113X the global variable, operation, etc. Note that this
  does not change the basic "layout" of the tree.[133X
  
  [33X[0;0YOn  the  contrary,  in  the following examples we change the "layout" of the
  tree:[133X
  
  [30X    [33X[0;6YIf  we  have a function call of a resolved function, we can assign the
        argument  values  to local variables at the beginning of the function.
        This way we can avoid passing arguments completely.[133X
  
  [30X    [33X[0;6YIf  a  function  call  of a resolved function occurs in the right hand
        side  of a variable assignment, we can insert the body of the resolved
        function  right  before the variable assignment. This way we can avoid
        the function call.[133X
  
  [30X    [33X[0;6YWe  can  replace  all references to a local variable by the right hand
        side of the variable assignment and then drop the assignment.[133X
  
  [33X[0;0YWe  call  this  [13Xinlining[113X  the  function  arguments,  functions,  or variable
  assignments.[133X
  
  
  [1X1.2 [33X[0;0YCapabilities of the compiler[133X[101X
  
  [33X[0;0YThe  compilation  process  has  two phases: the resolving phase and the rule
  phase.[133X
  
  [33X[0;0YDuring the resolving phase, operations and global variables are resolved.[133X
  
  [30X    [33X[0;6YCAP  operations  can only be resolved if an instance of a CAP category
        to  which the operation is applied is known. Then, the functions added
        to  the  category via [10XAdd[110X functions are considered. Note that caching,
        pre functions, etc. are bypassed.[133X
  
  [30X    [33X[0;6YYou     can     also     use     [10XInstallMethodForCompilerForCAP[110X     or
        [10XInstallOtherMethodForCompilerForCAP[110X  (see the documentation of CAP) to
        make  methods  which accept a CAP category as the first argument known
        to the compiler. The same restrictions as for CAP operations apply.[133X
  
  [30X    [33X[0;6YReferences  to  global  functions are resolved if the function name is
        not  listed in [10XCAP_JIT_NON_RESOLVABLE_GLOBAL_VARIABLE_NAMES[110X and if the
        function is annotated with the pragma [10XCAP_JIT_RESOLVE_FUNCTION[110X.[133X
  
  [30X    [33X[0;6YIf  a  call  of  a global function or operation (occuring as the right
        hand  side  of  a  variable  assignment  or  as  the return value of a
        function)        is        annotated       with       the       pragma
        [10XCAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL[110X,  the compiler assumes that
        the  resolved  function never returns [10Xfail[110X and thus simply removes any
        code  of the form [10Xif condition then return fail; fi;[110X (or similar) from
        the  resolved  function.  The pragma has to be placed right before the
        variable assignment or the return statement.[133X
  
  [30X    [33X[0;6YIf  the  pragma  [10XCAP_JIT_DROP_NEXT_STATEMENT[110X  occurs  in  the resolved
        function, the statement following the pragma is removed.[133X
  
  [33X[0;0YFor      details      see      [2XCapJitResolvedOperations[102X     ([14X2.5-20[114X)     and
  [2XCapJitResolvedGlobalVariables[102X  ([14X2.5-19[114X).  If no operation or global variable
  can be resolved anymore, we continue with the rule phase.[133X
  
  [33X[0;0YIn the rule phase, the tree is optimized using several rules and techniques.
  Function  arguments,  functions,  and  assignments  to  local  variables are
  inlined.  Unused variables are dropped. Handled edge cases are dropped, that
  is,  if  the  same  edge case is caught multiple times via [10Xif condition then
  return  ...; fi;[110X statements, only the first such statement is kept. Finally,
  "logic"  is  applied  to  the  tree.  For example, calls of [10XCallFuncList[110X are
  replaced  by  calls to the actual function. The logic can be extended by the
  user, see chapter [14X2[114X.[133X
  
  [33X[0;0YFor all details, see the list of compilations steps in [14X2.5[114X.[133X
  
  
  [1X1.3 [33X[0;0YRequirements[133X[101X
  
  [33X[0;0YThere are some requirements for the steps described above to be correct:[133X
  
  [30X    [33X[0;6YThe  code must not depend on side effects (otherwise dropping "unused"
        variables or inlining variables could change results).[133X
  
  [30X    [33X[0;6YTechnically,  the  result  is only valid for the concrete CAP category
        which  was  used to resolve CAP operations and get typing information.
        That  is,  for parametric categories you must check manually for which
        parameters the result is valid.[133X
  
  [30X    [33X[0;6YOnly  assignments  to  local  variables,  if/elif/else statements, and
        return statements are allowed as statements in functions.[133X
  
  [30X    [33X[0;6YAll  branches  of  any  given  if/elif/else  statement must end with a
        return statement or the assignment to the same local variable.[133X
  
  [30X    [33X[0;6YIf  statements  must  always  have  an  else  statement, except if all
        branches  end  with  a  return  statement.  In  the  latter  case, the
        statements  following  the  if statement are automatically put into an
        else statement.[133X
  
  [30X    [33X[0;6YNested if/elif/else statements are not allowed.[133X
  
  [30X    [33X[0;6YFunction arguments or local variables must not be called [10XRETURN_VALUE[110X,
        as this name is used internally.[133X
  
  [30X    [33X[0;6YLocal  variables must be assigned at most once (this includes function
        arguments,  which are assigned at least once, namely when the function
        is  called).  An  exception  is made for "rapid reassignments": if the
        same  variable is assigned and then reassigned immediately in the next
        statement, this only counts as a single assignment.[133X
  
  [30X    [33X[0;6YSince the compiler might change the order of statements, checking if a
        local variable (or list entry etc.) is bound is not safe.[133X
  
  [30X    [33X[0;6YFor performance optimizations, the compiler might move expressions out
        of  if/else  statements,  e.g.  if  they  occur  inside a (potentially
        expensive)  [10XList[110X  call.  Thus,  code  inside  if/else  statements must
        execute without error even if moved outside of the if/else statement.[133X
  
  [33X[0;0YAdditionally,  there  is  no  detection  for  recursive  function  calls, so
  resolving such a function call leads to an infinite loop.[133X
  
  
  [1X1.4 [33X[0;0YPrecompiling categories[133X[101X
  
  [33X[0;0YThe  main mode of application of the compiler is precompiling categories and
  storing  the  result  in  a  file for later use via [2XCapJitPrecompileCategory[102X
  ([14X1.4-1[114X).[133X
  
  [1X1.4-1 CapJitPrecompileCategory[101X
  
  [33X[1;0Y[29X[2XCapJitPrecompileCategory[102X( [3Xcategory_constructor[103X, [3Xgiven_arguments[103X, [3Xpackage_name[103X, [3Xcompiled_category_name[103X ) [32X function[133X
  
  [33X[0;0YCompiles   operations   of   the  CAP  category  returned  by  the  function
  [3Xcategory_constructor[103X applied to [3Xgiven_arguments[103X. The result is available via
  a global function called [3Xcompiled_category_name[103X which is written to the file
  [3Xpackage_name[103X[10X/precompiled_categories/[110X[3Xcompiled_category_name[103X[10X.gi[110X.   The  global
  function  takes  the  same arguments as [3Xcategory_constructor[103X and returns the
  category with the compiled functions installed as primitive operations. If a
  list  of  operations  is given via the option [10Xoperations[110X, only operations in
  this   list  are  precompiled.  Else  all  installed  operations  (excluding
  operations  which  are  part  of suggested dependencies) of the category are
  precompiled. Technical requirements:[133X
  
  [30X    [33X[0;6Y[3Xcategory_constructor[103X must be a regular function, i.e. not an operation
        or a kernel function.[133X
  
  [30X    [33X[0;6Y[3Xcategory_constructor[103X   must   support   the  option  [10XFinalizeCategory[110X.
        WARNING:  When  using attributes you might run into errors because the
        options  are  only  respected  the  first  time you call the attribute
        getter.  To catch such a situation, [3Xcategory_constructor[103X is applied to
        [3Xgiven_arguments[103X    twice    and   if   the   results   are   identical
        ([10XIsIdenticalObj[110X) an error is raised.[133X
  
  [30X    [33X[0;6YCAP  operations  returning  [10Xfail[110X  are  excluded  from  the compilation
        because they usually do not fulfill all requirements of the compiler.[133X
  
  [1X1.4-2 CapJitPrecompileCategoryAndCompareResult[101X
  
  [33X[1;0Y[29X[2XCapJitPrecompileCategoryAndCompareResult[102X( [3Xcategory_constructor[103X, [3Xgiven_arguments[103X, [3Xpackage_name[103X, [3Xcompiled_category_name[103X ) [32X function[133X
  
  [33X[0;0YCalls [2XCapJitPrecompileCategory[102X ([14X1.4-1[114X) with the given arguments and displays
  a      warning      if      this      changes      the      contents      of
  [3Xpackage_name[103X[10X/precompiled_categories/[110X[3Xcompiled_category_name[103X[10X.gi[110X.[133X
  
  
  [1X1.5 [33X[0;0YCompiling a function manually[133X[101X
  
  [33X[0;0YOne  can  also  compile  a function [10Xfunc[110X manually via [2XCapJitCompiledFunction[102X
  ([14X1.5-2[114X).[133X
  
  [1X1.5-1 CapJitCompiledCAPOperationAsEnhancedSyntaxTree[101X
  
  [33X[1;0Y[29X[2XCapJitCompiledCAPOperationAsEnhancedSyntaxTree[102X( [3Xcat[103X, [3Xoperation_name[103X ) [32X function[133X
  
  [33X[0;0YA  special  version  of  [2XCapJitCompiledFunctionAsEnhancedSyntaxTree[102X  ([14X1.5-3[114X)
  compiling the operation given by [3Xoperation_name[103X in [3Xcat[103X.[133X
  
  [1X1.5-2 CapJitCompiledFunction[101X
  
  [33X[1;0Y[29X[2XCapJitCompiledFunction[102X( [3Xfunc[103X[, [3Xtype_signature[103X] ) [32X function[133X
  [6XReturns:[106X  [33X[0;10Ya function[133X
  
  [33X[0;0YReturns   a   compiled   version   of   the  function  [3Xfunc[103X  with  signature
  [3Xtype_signature[103X   (see   [2XCapJitInferredDataTypes[102X  ([14X2.5-9[114X)).  If  [3Xfunc[103X  is  an
  operation  or a kernel function, it is returned unchanged. If [3Xtype_signature[103X
  is not given, all steps which require knowledge about the types of variables
  are  skipped.  The  type  signature  can  also  be  given  by three separate
  arguments: a CAP category, a list of input filters (as in [10Xfilter_list[110X in the
  method  name  record)  and an output filter (as in [10Xreturn_type[110X in the method
  name  record).  If  a  full  type  signature  is not available but the first
  argument  of  [3Xfunc[103X  is  a CAP category, an instance of a CAP category can be
  given  as the second argument. In this case, the category is used to get the
  type information required to resolve CAP operations.[133X
  
  [1X1.5-3 CapJitCompiledFunctionAsEnhancedSyntaxTree[101X
  
  [33X[1;0Y[29X[2XCapJitCompiledFunctionAsEnhancedSyntaxTree[102X( [3Xfunc[103X[, [3Xtype_signature[103X] ) [32X function[133X
  [6XReturns:[106X  [33X[0;10Ya record[133X
  
  [33X[0;0YLike  [2XCapJitCompiledFunction[102X ([14X1.5-2[114X), but returns an enhanced syntax tree of
  the  compiled  function.  [3Xfunc[103X must not be an operation or a kernel function
  because those cannot properly be represented as a syntax tree.[133X
  
  
  [1X1.6 [33X[0;0YGiving hints to the compiler[133X[101X
  
  [33X[0;0YYou can give hints to the compiler to improve the result of the compilation.
  Compiler    hints    are    attached    to    the    category    by   making
  [10Xcategory!.compiler_hints[110X a record with one or more of the following keys:[133X
  
  [30X    [33X[0;6Y[10Xcategory_attribute_names[110X:  a  list  of  names  of  attributes  of  the
        category. If a global variable in the compiled code has the same value
        as one of the given attributes of the category, the global variable is
        replaced  by the attribute getter applied to the category. Background:
        During  the  compilation, the compiler resolves attributes occuring in
        the    code    and    stores   them   in   global   variables   called
        [10XCAP_JIT_INTERNAL_GLOBAL_VARIABLE_n[110X  (for  integers [10Xn[110X starting from 1).
        If  these  variables  cannot  be  replaced, the resulting code is only
        valid in the current session.[133X
  
  [30X    [33X[0;6Y[10Xsource_and_range_attributes_from_morphism_attribute[110X:   a  record  with
        keys          [10Xobject_attribute_name[110X,          [10Xmorphism_attribute_name[110X,
        [10Xsource_attribute_getter_name[110X,     and     [10Xrange_attribute_getter_name[110X.
        Replaces  the  attribute  [10Xobject_attribute_name[110X  of  the source (resp.
        range)   of   a   morphism   by   [10Xsource_attribute_getter_name[110X  (resp.
        [10Xrange_attribute_getter_name[110X)      applied     to     the     attribute
        [10Xmorphism_attribute_name[110X  of  the  morphism. Can be used if objects and
        morphisms  can be easily created from the morphism datum anyway. Note:
        Some simple expressions like integers are NOT replaced.[133X
  
  [33X[0;0YNote:  The compiler can only discover the hints if the category is the first
  argument of the function.[133X
  
  
  [1X1.7 [33X[0;0YStopping the compiler at a certain level[133X[101X
  
  [33X[0;0YYou  can use [10XStopCompilationAtCategory[110X to prevent the compiler from inlining
  and  optimizing code of a given category. You can revert this decision using
  [10XContinueCompilationAtCategory[110X.[133X
  
  [1X1.7-1 StopCompilationAtCategory[101X
  
  [33X[1;0Y[29X[2XStopCompilationAtCategory[102X( [3Xcategory[103X ) [32X function[133X
  
  [33X[0;0YStops the compiler from inlining and optimizing code of [3Xcategory[103X.[133X
  
  [1X1.7-2 ContinueCompilationAtCategory[101X
  
  [33X[1;0Y[29X[2XContinueCompilationAtCategory[102X( [3Xcategory[103X ) [32X function[133X
  
  [33X[0;0YAllows  the  compiler  to  inline and optimize code of [3Xcategory[103X (this is the
  default).[133X
  
  [1X1.7-3 StopCompilationAtPrimitivelyInstalledOperationsOfCategory[101X
  
  [33X[1;0Y[29X[2XStopCompilationAtPrimitivelyInstalledOperationsOfCategory[102X( [3Xcategory[103X ) [32X function[133X
  
  [33X[0;0YStops  the  compiler  from  inlining  and  optimizing  code  of  primitively
  installed  operations  of  [3Xcategory[103X. Warning: Due to caching of compiled CAP
  operations, this has to be called before any compilation involving [3Xcategory[103X.[133X
  
  [1X1.7-4 ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory[101X
  
  [33X[1;0Y[29X[2XContinueCompilationAtPrimitivelyInstalledOperationsOfCategory[102X( [3Xcategory[103X ) [32X function[133X
  
  [33X[0;0YAllows  the  compiler  to  inline and optimize code of primitively installed
  operations of [3Xcategory[103X (this is the default).[133X
  
  
  [1X1.8 [33X[0;0YDisabling the automatic inference of data types[133X[101X
  
  [1X1.8-1 CapJitDisableDataTypeInference[101X
  
  [33X[1;0Y[29X[2XCapJitDisableDataTypeInference[102X( [3Xarg[103X ) [32X function[133X
  [33X[1;0Y[29X[2XCapJitEnableDataTypeInference[102X( [3Xarg[103X ) [32X function[133X
  
  [33X[0;0YIn  case  of  errors,  the automatic inference of data types can be disabled
  (and re-enabled later on).[133X
  
  
  [1X1.9 [33X[0;0YGetting information about the compilation process[133X[101X
  
  [33X[0;0YYou  can  increase the info level of [10XInfoCapJit[110X to get information about the
  compilation process.[133X
  
  [1X1.9-1 InfoCapJit[101X
  
  [33X[1;0Y[29X[2XInfoCapJit[102X [32X info class[133X
  
  [33X[0;0YInfo class used for info messsages of the CAP compiler.[133X
  
  
  [1X1.10 [33X[0;0YFAQ[133X[101X
  
  [30X    [33X[0;6YQ: Why is my function not resolved?[133X
  
  [33X[0;0YA:        The        function        might        be        listed        in
  [10XCAP_JIT_NON_RESOLVABLE_GLOBAL_VARIABLE_NAMES[110X  or  it  might  be  missing  an
  annotation   with   the  pragma  [10XCAP_JIT_RESOLVE_FUNCTION[110X.  Additionally,  a
  function can only be resolved if it appears as a global variable in the tree
  during  the  resolving  phase  of  the  compilation.  That  is,  it  must be
  referenced  from  a  global  variable from the beginning on, or after global
  variables  are  resolved by [2XCapJitResolvedGlobalVariables[102X ([14X2.5-19[114X). Possibly
  you have adapt [2XCapJitResolvedGlobalVariables[102X ([14X2.5-19[114X) to your setting.[133X
  
  [30X    [33X[0;6YQ:  Why  is  do  I get the error "a local variable with name <name> is
        assigned  more than once (not as a part of a rapid reassignment), this
        is not supported"?[133X
  
  [33X[0;0YA:  For reasons of correctness, variables cannot be inlined if a variable is
  assigned  more  than  once in the body of a function (this includes function
  arguments  which  are  assigned  at  least once, namely when the function is
  called).  An  exception  is  made  for  "rapid  reassignments":  if the same
  variable  is assigned and then reassigned immediately in the next statement,
  this only counts as a single assignment.[133X
  
  [30X    [33X[0;6YQ: Why do I get one of the following errors: "tree includes statements
        or  expressions  which indicate possible side effects", "tree contains
        an  assignment  of a higher variable with initial name <name>, this is
        not  supported",  or  "tree contains for loop over non-local variable,
        this is not supported" ?[133X
  
  [33X[0;0YA:  We  can  only drop unused variables, inline variables, etc. if we assume
  that  the  code  contains  no side effects. Statements like STAT_PROCCALL or
  assignment to higher variables cause (or at least indicate) side effects, so
  continuing with the compilation would probably not lead to a correct result.[133X
  
