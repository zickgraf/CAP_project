<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (CompilerForCAP) - Chapter 2: Improving and extending the compiler</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X7D62EFD07F991E56" name="X7D62EFD07F991E56"></a></p>
<div class="ChapSects"><a href="chap2.html#X7D62EFD07F991E56">2 <span class="Heading">Improving and extending the compiler</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X86EC986580F17F44">2.1 <span class="Heading">Logic</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X804E3CAD82BE47BB">2.1-1 CapJitAddLogicFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8592DC367A493530">2.1-2 CapJitAddLogicTemplate</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X84E0923883AE3917">2.2 <span class="Heading">Enhanced syntax trees</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X820FCB30796F2486">2.2-1 ENHANCED_SYNTAX_TREE</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7803FE057B30BAAF">2.2-2 ENHANCED_SYNTAX_TREE_CODE</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X867D15087B608A10">2.3 <span class="Heading">Iterating over a syntax tree</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C227788859AA50E">2.3-1 CapJitIterateOverTree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X82D5E91180359D94">2.3-2 CapJitIterateOverTreeWithCachedBindingResults</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8508AEF8845565A1">2.4 <span class="Heading">Tools</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X868F5CD681DAFA69">2.4-1 CapJitPrettyPrintSyntaxTree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7BF496F97D50591D">2.4-2 CapJitIsCallToGlobalFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7869C74E78CAAB21">2.4-3 CapJitResultFuncCombineChildren</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X856A15627FE43A24">2.4-4 CapJitContainsRefToFVAROutsideOfFuncStack</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8195576380113ACF">2.4-5 CapJitGetOrCreateGlobalVariable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X84BE00B18663765C">2.4-6 CapJitFindNodeDeep</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7ACEA9D087F47BE6">2.4-7 CapJitFindNodes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B97567F7B56CBFA">2.4-8 CapJitGetNodeByPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7981CA50837DB87A">2.4-9 CapJitRemovedReturnFail</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X79A0FCEC7F45C5F1">2.4-10 CapJitPrettyPrintFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A76B5D0839AF130">2.4-11 CapJitCopyWithNewFunctionIDs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7DB6AB468352F1A9">2.4-12 CapJitIsEqualForEnhancedSyntaxTrees</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80D89E2F80AA299E">2.4-13 CapJitAddBinding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F9980828043C895">2.4-14 CapJitValueOfBinding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X823022237A2584E6">2.4-15 CapJitUnbindBinding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A17377380E409D0">2.4-16 CapJitReplacedEXPR_REF_FVARByValue</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E53C09D7DD16BE3">2.4-17 CapJitGetNextUnusedVariableID</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X80608A9A78CF95E0">2.5 <span class="Heading">Compilation steps</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7EA532657F3F6322">2.5-1 CapJitAppliedCompilerHints</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X818C330582C88DE6">2.5-2 CapJitReplacedGlobalVariablesByCategoryAttributes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X797464D18296B4BC">2.5-3 CapJitReplacedSourceAndRangeAttributes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B2CAFD1864FA422">2.5-4 CapJitDeduplicatedExpressions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A46699B7922FB1B">2.5-5 CapJitDroppedHandledEdgeCases</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F43BA10869178AC">2.5-6 CapJitDroppedUnusedBindings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X82763C7D7CAD3B16">2.5-7 CapJitHoistedExpressions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7ADA6AEF8564A0EE">2.5-8 CapJitHoistedBindings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X821BE2CE7C30674E">2.5-9 CapJitInferredDataTypes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7DF03AC082073C4C">2.5-10 CapJitInlinedArguments</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X83E0BBEA80AD5CDE">2.5-11 CapJitInlinedBindings</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X82F8D6B5851674EB">2.5-12 CapJitInlinedBindingsToVariableReferences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X794E5E1F7D86BFAA">2.5-13 CapJitInlinedBindingsFully</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7933165D803DEDB2">2.5-14 CapJitInlinedFunctionCalls</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C3064C27FBB1A0D">2.5-15 CapJitInlinedSimpleFunctionCalls</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X837576207D282C04">2.5-16 CapJitAppliedLogic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7AE756B8878FD449">2.5-17 CapJitAppliedLogicTemplates</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X79FD7D407C591072">2.5-18 CapJitOutlinedWrappedArguments</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7FD883BA85F7EBE5">2.5-19 CapJitResolvedGlobalVariables</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D12C378812745DA">2.5-20 CapJitResolvedOperations</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">Improving and extending the compiler</span></h3>

<p>The easiest way to extend the compiler is by adding more logic to it, see <a href="chap2.html#X86EC986580F17F44"><span class="RefLink">2.1</span></a>. For writing logic functions you also have to iterate over enhanced syntax trees, see <a href="chap2.html#X84E0923883AE3917"><span class="RefLink">2.2</span></a> and <a href="chap2.html#X867D15087B608A10"><span class="RefLink">2.3</span></a>. You might also want to use available tools, see <a href="chap2.html#X8508AEF8845565A1"><span class="RefLink">2.4</span></a>. If you want to improve an existing compilation step or add a completely new one, see <a href="chap2.html#X80608A9A78CF95E0"><span class="RefLink">2.5</span></a>.</p>

<p>For debugging you can:</p>


<ul>
<li><p>use <code class="func">CapJitPrettyPrintSyntaxTree</code> (<a href="chap2.html#X868F5CD681DAFA69"><span class="RefLink">2.4-1</span></a>),</p>

</li>
<li><p>set <code class="code">debug</code> to <code class="code">true</code> in the code of <code class="func">CapJitCompiledFunctionAsEnhancedSyntaxTree</code> (<a href="chap1.html#X7B1445EE85D8CA0A"><span class="RefLink">1.5-3</span></a>) (Note: this causes informational break loops which are not actual errors),</p>

</li>
<li><p>use the <code class="code">debug</code> and <code class="code">debug_path</code> record entries of logic templates (see <code class="func">CapJitAddLogicTemplate</code> (<a href="chap2.html#X8592DC367A493530"><span class="RefLink">2.1-2</span></a>)).</p>

</li>
</ul>
<p><a id="X86EC986580F17F44" name="X86EC986580F17F44"></a></p>

<h4>2.1 <span class="Heading">Logic</span></h4>

<p>Warning: When writing logic functions and templates keep in mind that wrapped arguments are outlined, see <code class="func">CapJitOutlinedWrappedArguments</code> (<a href="chap2.html#X79FD7D407C591072"><span class="RefLink">2.5-18</span></a>). This means that for example a logic template of the form <code class="code">ObjectifyObjectForCAPWithAttributes( rec( ), cat, attr, MyFunction( x ) )</code> will never match because <code class="code">MyFunction( x )</code> is outlined to a local variable.</p>

<p><a id="X804E3CAD82BE47BB" name="X804E3CAD82BE47BB"></a></p>

<h5>2.1-1 CapJitAddLogicFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitAddLogicFunction</code>( <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Adds the function <var class="Arg">func</var> to the list of logic functions. For a list of pre-installed logic functions, which can be used as guiding examples, see <code class="code">CompilerForCAP/gap/Logic.gi</code>. Technically, <var class="Arg">func</var> should accept an (enhanced) syntax tree and return an (enhanced) syntax tree. Semantically, <var class="Arg">func</var> should use some kind of "logic" to transform the tree. For example, <var class="Arg">func</var> could look for calls of <code class="code">CallFuncList</code> and replace them by calls to the actual function. Note: Often it is easier to use a logic template (see <code class="func">CapJitAddLogicTemplate</code> (<a href="chap2.html#X8592DC367A493530"><span class="RefLink">2.1-2</span></a>)) than a logic function.</p>

<p><a id="X8592DC367A493530" name="X8592DC367A493530"></a></p>

<h5>2.1-2 CapJitAddLogicTemplate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitAddLogicTemplate</code>( <var class="Arg">template</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Adds the logic template <var class="Arg">template</var> to the list of logic templates. For a list of pre-installed logic templates, which can be used as guiding examples, see <code class="code">CompilerForCAP/gap/LogicTemplates.gi</code>. Logic templates are records with the following entries:</p>


<ul>
<li><p><code class="code">src_template</code> and <code class="code">dst_template</code> (required): strings containing valid GAP code defining expressions</p>

</li>
<li><p><code class="code">variable_names</code> (required): a list of strings</p>

</li>
<li><p><code class="code">variable_filters</code> (optional): a list of filters with the same length as <code class="code">variable_names</code>, defaults to a list of <code class="code">IsObject</code></p>

</li>
<li><p><code class="code">new_funcs</code> (optional): a list of lists of strings, defaults to the empty list</p>

</li>
<li><p><code class="code">needed_packages</code> (optional): a list of pairs (i.e. lists with two entries) of strings, defaults to the empty list</p>

</li>
<li><p><code class="code">debug</code> (optional): a boolean</p>

</li>
<li><p><code class="code">debug_path</code> (optional): a path</p>

</li>
</ul>
<p>Semantics: <code class="code">src_template</code> is a piece of code which should be replaced by <code class="code">dst_template</code>:</p>


<ul>
<li><p>The function <code class="func">CapJitAppliedLogicTemplates</code> (<a href="chap2.html#X7AE756B8878FD449"><span class="RefLink">2.5-17</span></a>) tries to find occurences of <code class="code">src_template</code> in a tree and potentially replaces them by <code class="code">dst_template</code>.</p>

</li>
<li><p>When trying to find an occurence of <code class="code">src_template</code> in a tree, all strings occuring in the list <code class="code">variable_names</code> are considered as variables, i.e., they match any value in the tree. If a variable occurs multiple times, the corresponding parts of the tree must be equal. The template is only applied if all values match the corresponding filters in <code class="code">variable_filters</code>.</p>

</li>
<li><p>For each function in <code class="code">dst_template</code>, <code class="func">CapJitAppliedLogicTemplates</code> (<a href="chap2.html#X7AE756B8878FD449"><span class="RefLink">2.5-17</span></a>) tries to find a corresponding function in <code class="code">src_template</code>. The functions are matched by comparing the lists of names of local variables. If for a function in <code class="code">dst_template</code> no corresponding function in <code class="code">src_template</code> exists, you have to add the list of names of local variables of this function to <code class="code">new_funcs</code>.</p>

</li>
<li><p><code class="code">needed_packages</code> has the same format as <code class="code">NeededOtherPackages</code> in <code class="code">PackageInfo.g</code>. The template is only evaluated if the packages in <code class="code">needed_packages</code> are loaded in the correct versions.</p>

</li>
<li><p><code class="code">debug</code> can be set to <code class="code">true</code> to print more information while <code class="func">CapJitAppliedLogicTemplates</code> (<a href="chap2.html#X7AE756B8878FD449"><span class="RefLink">2.5-17</span></a>) tries to apply the template. (Note: this causes informational break loops which are not actual errors).</p>

</li>
<li><p><code class="code">debug_path</code> can be set to a specific path to get exact information why the subtree at this path does or does not match <code class="code">src_template</code>.</p>

</li>
</ul>
<p>Notes:</p>


<ul>
<li><p><code class="code">src_template</code> is only replaced by <code class="code">dst_template</code> if the result is well-defined, i.e., if all function variables reference only functions in their function stack. This can be used to move "static" variables (i.e. variables not depending on local variables) outside of functions. Example: consider a template with <code class="code">src_template</code> given by <code class="code">Sum( List( L, x -&gt; x^2 * value ) )</code> and <code class="code">dst_template</code> given by <code class="code">Sum( List( L, x -&gt; x^2 ) ) * value</code> (assuming distributivity). This replacement is only valid if <code class="code">value</code> is independent of <code class="code">x</code>. However, we do not need to make this explicit at any point, because if <code class="code">value</code> depends on <code class="code">x</code>, the result <code class="code">Sum( List( L, x -&gt; x^2 ) ) * value</code> is not well-defined, so the template is not applied anyway.</p>

</li>
<li><p>If <code class="code">src_template</code> cannot be expressed as valid GAP code, the component <code class="code">src_template_tree</code> can be set. In that case, <code class="code">src_template</code> is not parsed and <code class="code">src_template_tree</code> is used when trying to find a match. Variables in the sense of <code class="code">variable_names</code> have to be given as syntax trees of type <code class="code">SYNTAX_TREE_VARIABLE</code> with a unique <code class="code">id</code>. Setting <code class="code">src_template</code> and <code class="code">variable_names</code> is still required to have a readable representation of the template. If <code class="code">dst_template</code> cannot be expressed as valid GAP code, it can be in an analogous manner.</p>

</li>
</ul>
<p><a id="X84E0923883AE3917" name="X84E0923883AE3917"></a></p>

<h4>2.2 <span class="Heading">Enhanced syntax trees</span></h4>

<p>To simplify the handling of syntax trees, the CAP compiler enhances syntax trees in the following ways:</p>


<ul>
<li><p>Lists are transformed (in the expected way) into records of type SYNTAX_TREE_LIST with integer keys (and an additional key <code class="code">length</code>).</p>

</li>
<li><p>All node types starting with STAT_SEQ_STAT are replaced by STAT_SEQ_STAT.</p>

</li>
<li><p>All node types starting with EXPR_FUNCCALL_ are replaced by EXPR_FUNCCALL.</p>

</li>
<li><p>All node types starting with EXPR_PROCCALL_ are replaced by EXPR_PROCCALL.</p>

</li>
<li><p>All node types starting with STAT_FOR are replaced by STAT_FOR.</p>

</li>
<li><p>Nested STAT_SEQ_STATs are flattened.</p>

</li>
<li><p>A final STAT_RETURN_VOID in functions is dropped.</p>

</li>
<li><p>Branches of STAT_IF etc. are given the type BRANCH_IF.</p>

</li>
<li><p>If the body of a BRANCH_IF is not a STAT_SEQ_STAT, the body is wrapped in a STAT_SEQ_STAT.</p>

</li>
<li><p>The key-value pairs of EXPR_RECs are given the type REC_KEY_VALUE_PAIR.</p>

</li>
<li><p>A globally unique ID is assigned to each function.</p>

</li>
<li><p>Return statements are replaced by assignments to a special local variable "RETURN_VALUE".</p>

</li>
<li><p>The handling of local variables and higher variables is unified by the concept of function variables: function variables (FVARs) reference local variables in functions via the function id (<code class="code">func_id</code>) and their name (<code class="code">name</code>), which is determined from the list of arguments/local variables of the function.</p>

</li>
<li><p>All statements after <code class="code">if ... then return ...; fi;</code> are moved into an <code class="code">else</code> branch.</p>

</li>
<li><p>The syntax tree types in <code class="code">CAP_JIT_INTERNAL_SYNTAX_TREE_TO_OPERATION_TRANSLATIONS</code> (e.g. <code class="code">EXPR_ELM_MAT</code>) are replaced by calls to corresponding operations (so that they do not require special handling).</p>

</li>
<li><p>if/elif/else statements must all end with the assignment to the same local variable and must have an else clause. They are coded using a new type <code class="code">EXPR_CASE</code>: Trees of type <code class="code">EXPR_CASE</code> have a key <code class="code">branches</code> which holds a list of trees of type <code class="code">CASE_BRANCH</code>. Trees of type <code class="code">CASE_BRANCH</code> have two keys <code class="code">condition</code> and <code class="code">value</code>, which get populated with the condition of the if branch and the right hand side of the last variable assignment in the body of the branch. Caution: The remaining statements in the body of the if branch are moved outside of the if/elif/else statement!</p>

</li>
<li><p>Statements which are not assignments to local variables or if/else statements as well as nested if/else statements are not supported.</p>

</li>
<li><p><code class="code">EXPR_FUNC</code>s are coded as <code class="code">EXPR_DECLARATIVE_FUNC</code>s: The latter has not key <code class="code">nloc</code> and no key <code class="code">name</code>. Additionally, instead of <code class="code">stats</code>, the latter has a key <code class="code">bindings</code> of type <code class="code">FVAR_BINDING_SEQ</code>. A syntax tree of type <code class="code">FVAR_BINDING_SEQ</code> describes a set(!) of bindings (= assignments) of local variables. It has a key <code class="code">names</code>, a list of bound names. Values of bindings can be added/obtained/unbound via <code class="code">CapJitAddBinding</code>, <code class="code">CapJitValueOfBinding</code>, and <code class="code">CapJitUnbindBinding</code>. When the tree to a function again, the set of bindings is endowed with a order which respects the relation "uses".</p>

</li>
<li><p>Local variables must not be assigned more than once (this includes function arguments, which are assigned at least once, namely when the function is called). An exception is made for "rapid reassignments": if the same variable is assigned and then reassigned immediately in the next statement, the right-hand side of the first assignment is inserted into the right-hand side of the second assignment.</p>

</li>
</ul>
<p><a id="X820FCB30796F2486" name="X820FCB30796F2486"></a></p>

<h5>2.2-1 ENHANCED_SYNTAX_TREE</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ENHANCED_SYNTAX_TREE</code>( <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Returns an enhanced syntax tree of the plain function <var class="Arg">func</var> (see above). If the option <code class="code">globalize_hvars</code> is set to <code class="code">true</code>, higher variables pointing to variables in the environment of <var class="Arg">func</var> are assigned to global variables and referenced via these global variables in the tree. Otherwise, an error is thrown if such higher variables exist. If a list is given as the option <code class="code">given_arguments</code>, references to the <code class="code">i</code>-th argument of the function are replaced by references to a global variable with the value of <code class="code">given_arguments[i]</code> (only in case this position is bound). If a type signature (see <code class="func">CapJitInferredDataTypes</code> (<a href="chap2.html#X821BE2CE7C30674E"><span class="RefLink">2.5-9</span></a>)) of <var class="Arg">func</var> is given as the option <code class="code">type_signature</code>, it is attached to the resulting tree.</p>

<p><a id="X7803FE057B30BAAF" name="X7803FE057B30BAAF"></a></p>

<h5>2.2-2 ENHANCED_SYNTAX_TREE_CODE</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ENHANCED_SYNTAX_TREE_CODE</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a function</p>

<p>Converts the enhanced syntax tree <var class="Arg">tree</var> to a function.</p>

<p><a id="X867D15087B608A10" name="X867D15087B608A10"></a></p>

<h4>2.3 <span class="Heading">Iterating over a syntax tree</span></h4>

<p><a id="X7C227788859AA50E" name="X7C227788859AA50E"></a></p>

<h5>2.3-1 CapJitIterateOverTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitIterateOverTree</code>( <var class="Arg">tree</var>, <var class="Arg">pre_func</var>, <var class="Arg">result_func</var>, <var class="Arg">additional_arguments_func</var>, <var class="Arg">additional_arguments</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: see description</p>

<p>Iterates recursively over a syntax tree and calls <var class="Arg">pre_func</var> and <var class="Arg">result_func</var> for each node. Overview:</p>


<ul>
<li><p><var class="Arg">pre_func</var> allows to modify a (sub-)tree before the recursion over its children. For example, you could detect occurrences of <code class="code">if true then &lt;body&gt; fi;</code> and simply return the body to simplify the tree.</p>

</li>
<li><p><var class="Arg">result_func</var> allows to construct the return value of a (sub-)tree from the return values of its children. For example, if you want to check if a node of a certain type occurs in the tree, return <code class="code">true</code> if <var class="Arg">tree</var> has the type or any of the children returned <code class="code">true</code>, otherwise return <code class="code">false</code>.</p>

</li>
<li><p><var class="Arg">additional_arguments[_func]</var> allows to create and pass additional data to the children of <var class="Arg">tree</var>, for example the path or the function stack.</p>

</li>
</ul>
<p>Details:</p>


<ul>
<li><p>First, <var class="Arg">pre_func</var> is called with the following arguments: <var class="Arg">tree</var> and <var class="Arg">additional_arguments</var>. If it returns <code class="code">fail</code>, the recursion is skipped and <var class="Arg">result_func</var> is called immediately with <code class="code">result</code> set to <code class="code">fail</code> (see below). Otherwise it must return a syntax tree, which is then used as the value of <var class="Arg">tree</var> for the remaining computation. If you do not need this function, use <code class="code">ReturnFirst</code>.</p>

</li>
<li><p>Secondly, for each child of <var class="Arg">tree</var>, <var class="Arg">additional_arguments_func</var> is called with the following arguments: <var class="Arg">tree</var>, the key of the child, and <var class="Arg">additional_arguments</var>. If <var class="Arg">tree</var> is a list, the key of a child is its list index. If <var class="Arg">tree</var> is a record, the key of a child is the corresponding record name of <var class="Arg">tree</var>. The return value is used in the next step.</p>

</li>
<li><p>Next, the recursion starts: for each child, <code class="func">CapJitIterateOverTree</code> is called again with the following arguments: the child, <var class="Arg">pre_func</var>, <var class="Arg">result_func</var>, <var class="Arg">additional_arguments_func</var>, and the return value of the call of <var class="Arg">additional_arguments_func</var> in the step above.</p>

</li>
<li><p>The results of the recursive calls are stored in the variable <code class="code">result</code>: If <var class="Arg">tree</var> is a list, <code class="code">result</code> is also a list and the <code class="code">i</code>-th entry of this list is the return value of the <code class="code">result_func</code> of the <code class="code">i</code>-th child. If <var class="Arg">tree</var> is a record, <code class="code">result</code> is also a record and <code class="code">result.(key)</code> is the return value of the <code class="code">result_func</code> of the child named <code class="code">key</code>.</p>

</li>
<li><p>Next, <var class="Arg">result_func</var> is called with the following arguments: <var class="Arg">tree</var>, <code class="code">result</code>, <code class="code">keys</code> (a list containing the children's keys), and <var class="Arg">additional_arguments</var>. The return value should be the result of the current tree formed by combining the results of the children. For an example see <code class="func">CapJitResultFuncCombineChildren</code> (<a href="chap2.html#X7869C74E78CAAB21"><span class="RefLink">2.4-3</span></a>).</p>

</li>
<li><p>Finally, the return value of <var class="Arg">result_func</var> is returned.</p>

</li>
</ul>
<p>Note: This function on its own does not modify the tree. However, you can make modifications in <var class="Arg">pre_func</var>, <var class="Arg">result_func</var>, and <var class="Arg">additional_arguments_func</var>. If you do not want to make these modifcations in-place, you can replace a (sub-)tree by a modified version in <var class="Arg">pre_func</var> and combine the modified (sub-)trees again using <code class="func">CapJitResultFuncCombineChildren</code> (<a href="chap2.html#X7869C74E78CAAB21"><span class="RefLink">2.4-3</span></a>) as <var class="Arg">result_func</var>.</p>

<p><a id="X82D5E91180359D94" name="X82D5E91180359D94"></a></p>

<h5>2.3-2 CapJitIterateOverTreeWithCachedBindingResults</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitIterateOverTreeWithCachedBindingResults</code>( <var class="Arg">tree</var>, <var class="Arg">pre_func</var>, <var class="Arg">result_func</var>, <var class="Arg">additional_arguments_func</var>, <var class="Arg">additional_arguments</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Same input and output as <code class="func">CapJitIterateOverTree</code> (<a href="chap2.html#X7C227788859AA50E"><span class="RefLink">2.3-1</span></a>), but the results of bindings are cached and</p>


<ul>
<li><p>if we reach an <code class="code">EXPR_REF_FVAR</code> the result of the corresponding binding is given as <code class="code">result</code> for <var class="Arg">result_func</var>,</p>

</li>
<li><p><code class="code">pre_func</code> will not be called for <code class="code">FVAR_BINDING_SEQ</code>s,</p>

</li>
<li><p>the <code class="code">result</code> for <code class="code">FVAR_BINDING_SEQ</code>s will only contain used bindings, and</p>

</li>
<li><p>the <code class="code">keys</code> for <code class="code">FVAR_BINDING_SEQ</code>s will only contain the names of used bindings and will be ordered compatible with the "uses" relation on bindings, i.e. if a binding contains references to another binding, the name of the other binding will come first in <code class="code">keys</code>.</p>

</li>
</ul>
<p>WARNING: Calls to <code class="code">CapJitIterateOverTreeWithCachedBindingResults</code> must not be nested if this results in a function being visited twice.</p>

<p><a id="X8508AEF8845565A1" name="X8508AEF8845565A1"></a></p>

<h4>2.4 <span class="Heading">Tools</span></h4>

<p><a id="X868F5CD681DAFA69" name="X868F5CD681DAFA69"></a></p>

<h5>2.4-1 CapJitPrettyPrintSyntaxTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitPrettyPrintSyntaxTree</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Displays an enhanced syntax tree in a more useful way. For example, prints the type of a node on top.</p>

<p><a id="X7BF496F97D50591D" name="X7BF496F97D50591D"></a></p>

<h5>2.4-2 CapJitIsCallToGlobalFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitIsCallToGlobalFunction</code>( <var class="Arg">tree</var>, <var class="Arg">condition</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a boolean</p>

<p>Checks if <var class="Arg">tree</var> is an EXPR_FUNCCALL with <code class="code">funcref</code> EXPR_GVAR such that <code class="code">gvar</code> fulfills <var class="Arg">condition</var>. If <var class="Arg">condition</var> is a string, <code class="code">gvar</code> must be equal to the string. Othwerwise, <var class="Arg">condition</var> must be a function returning a boolean when applied to <code class="code">gvar</code>.</p>

<p><a id="X7869C74E78CAAB21" name="X7869C74E78CAAB21"></a></p>

<h5>2.4-3 CapJitResultFuncCombineChildren</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitResultFuncCombineChildren</code>( <var class="Arg">tree</var>, <var class="Arg">result</var>, <var class="Arg">additional_arguments</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list or a record</p>

<p>Can be used as a <code class="code">result_func</code> for <code class="func">CapJitIterateOverTree</code> (<a href="chap2.html#X7C227788859AA50E"><span class="RefLink">2.3-1</span></a>). Replaces <var class="Arg">tree</var><code class="code">.(key)</code> (resp. <var class="Arg">tree</var><code class="code">[key]</code>) by <var class="Arg">result</var><code class="code">.(key)</code> (resp. <var class="Arg">result</var><code class="code">[key]</code>) for all keys of children of <var class="Arg">tree</var> and returns the result. See <code class="func">CapJitIterateOverTree</code> (<a href="chap2.html#X7C227788859AA50E"><span class="RefLink">2.3-1</span></a>) for more details.</p>

<p><a id="X856A15627FE43A24" name="X856A15627FE43A24"></a></p>

<h5>2.4-4 CapJitContainsRefToFVAROutsideOfFuncStack</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitContainsRefToFVAROutsideOfFuncStack</code>( <var class="Arg">tree</var>, <var class="Arg">initial_func_id_stack</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a boolean</p>

<p>Checks if <var class="Arg">tree</var> (with function ID stack <var class="Arg">initial_func_id_stack</var>) contains an FVAR which references a function outside of its function stack. Such a tree is not well-defined.</p>

<p><a id="X8195576380113ACF" name="X8195576380113ACF"></a></p>

<h5>2.4-5 CapJitGetOrCreateGlobalVariable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitGetOrCreateGlobalVariable</code>( <var class="Arg">value</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a string</p>

<p>Assigns <var class="Arg">value</var> to a global variable and returns the name of the global variable. If <var class="Arg">value</var> has already been assigned to a global variable by this function before, simply returns the name of that global variable.</p>

<p><a id="X84BE00B18663765C" name="X84BE00B18663765C"></a></p>

<h5>2.4-6 CapJitFindNodeDeep</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitFindNodeDeep</code>( <var class="Arg">tree</var>, <var class="Arg">condition_func</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record or fail</p>

<p>Finds a node in <var class="Arg">tree</var> for which <var class="Arg">condition_func</var> returns <code class="code">true</code>. For each node, <var class="Arg">condition_func</var> is called with the node and current path as arguments, and must return a boolean. If multiple nodes are found, children are preferred over their parents (i.e. a "deep" node is returned). If no node can be found, <code class="code">fail</code> is returned.</p>

<p><a id="X7ACEA9D087F47BE6" name="X7ACEA9D087F47BE6"></a></p>

<h5>2.4-7 CapJitFindNodes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitFindNodes</code>( <var class="Arg">tree</var>, <var class="Arg">condition_func</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>Finds all nodes in <var class="Arg">tree</var> for which <var class="Arg">condition_func</var> returns <code class="code">true</code>. For each node, <var class="Arg">condition_func</var> is called with the node and current path as arguments, and must return a boolean. Returns a list of nodes for which this call yields true.</p>

<p><a id="X7B97567F7B56CBFA" name="X7B97567F7B56CBFA"></a></p>

<h5>2.4-8 CapJitGetNodeByPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitGetNodeByPath</code>( <var class="Arg">tree</var>, <var class="Arg">path</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Gets the node of <var class="Arg">tree</var> with path <var class="Arg">path</var>. Throws an error if no such node exists.</p>

<p><a id="X7981CA50837DB87A" name="X7981CA50837DB87A"></a></p>

<h5>2.4-9 CapJitRemovedReturnFail</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitRemovedReturnFail</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Removes removes any statement of the form <code class="code">if condition then return fail; fi;</code> (or similar) from the statements of a <var class="Arg">tree</var> of type <code class="code">EXPR_FUNC</code>. Throws an error if it cannot find such a statement.</p>

<p><a id="X79A0FCEC7F45C5F1" name="X79A0FCEC7F45C5F1"></a></p>

<h5>2.4-10 CapJitPrettyPrintFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitPrettyPrintFunction</code>( <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a string</p>

<p>Pretty prints the function <var class="Arg">func</var> and returns the result. <var class="Arg">func</var> must be a regular function, i.e. not an operation or a kernel function.</p>

<p><a id="X7A76B5D0839AF130" name="X7A76B5D0839AF130"></a></p>

<h5>2.4-11 CapJitCopyWithNewFunctionIDs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitCopyWithNewFunctionIDs</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Returns a structural copy of the enhanced syntax <var class="Arg">tree</var> which is 1:1 except that all functions have new, unused IDs.</p>

<p><a id="X7DB6AB468352F1A9" name="X7DB6AB468352F1A9"></a></p>

<h5>2.4-12 CapJitIsEqualForEnhancedSyntaxTrees</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitIsEqualForEnhancedSyntaxTrees</code>( <var class="Arg">tree1</var>, <var class="Arg">tree2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a boolean</p>

<p>Returns <code class="code">true</code> if the enhanced syntax trees <var class="Arg">tree1</var> and <var class="Arg">tree2</var> are equal up to:</p>


<ul>
<li><p>renaming of arguments,</p>

</li>
<li><p>replacement of function IDs,</p>

</li>
<li><p>changing the names of global variables while still referencing the identical value.</p>

</li>
</ul>
<p><a id="X80D89E2F80AA299E" name="X80D89E2F80AA299E"></a></p>

<h5>2.4-13 CapJitAddBinding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitAddBinding</code>( <var class="Arg">bindings</var>, <var class="Arg">name</var>, <var class="Arg">value</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Adds a binding for <var class="Arg">name</var> with value <var class="Arg">value</var> to a syntax tree <var class="Arg">bindings</var> of type <code class="code">FVAR_BINDING_SEQ</code>.</p>

<p><a id="X7F9980828043C895" name="X7F9980828043C895"></a></p>

<h5>2.4-14 CapJitValueOfBinding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitValueOfBinding</code>( <var class="Arg">bindings</var>, <var class="Arg">name</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Gets the value of the binding named <var class="Arg">name</var> from a syntax tree <var class="Arg">bindings</var> of type <code class="code">FVAR_BINDING_SEQ</code>.</p>

<p><a id="X823022237A2584E6" name="X823022237A2584E6"></a></p>

<h5>2.4-15 CapJitUnbindBinding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitUnbindBinding</code>( <var class="Arg">bindings</var>, <var class="Arg">name</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Unbinds the the binding named <var class="Arg">name</var> from a syntax tree <var class="Arg">bindings</var> of type <code class="code">FVAR_BINDING_SEQ</code>.</p>

<p><a id="X7A17377380E409D0" name="X7A17377380E409D0"></a></p>

<h5>2.4-16 CapJitReplacedEXPR_REF_FVARByValue</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitReplacedEXPR_REF_FVARByValue</code>( <var class="Arg">tree</var>, <var class="Arg">func_id</var>, <var class="Arg">name</var>, <var class="Arg">value</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Replaces all subtrees of the enhanced syntax tree <var class="Arg">tree</var> which are of type EXPR_REF_FVAR with given <var class="Arg">func_id</var> and <var class="Arg">name</var> by <var class="Arg">value</var>.</p>

<p><a id="X7E53C09D7DD16BE3" name="X7E53C09D7DD16BE3"></a></p>

<h5>2.4-17 CapJitGetNextUnusedVariableID</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitGetNextUnusedVariableID</code>( <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: an integer</p>

<p>Returns the minimal positive integer <span class="Math">n</span> such that no name of a local variable of the function <var class="Arg">func</var> (given as an enhanced syntax tree) ends with <code class="code">String( </code><span class="Math">m</span><code class="code"> )</code> for any <span class="Math">m \geq n</span>.</p>

<p><a id="X80608A9A78CF95E0" name="X80608A9A78CF95E0"></a></p>

<h4>2.5 <span class="Heading">Compilation steps</span></h4>

<p><a id="X7EA532657F3F6322" name="X7EA532657F3F6322"></a></p>

<h5>2.5-1 CapJitAppliedCompilerHints</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitAppliedCompilerHints</code>( <var class="Arg">tree</var>, <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Applies all compiler hints (see <a href="chap1.html#X7E61259E7D6E8EEB"><span class="RefLink">1.6</span></a>) to <var class="Arg">tree</var>.</p>

<p><a id="X818C330582C88DE6" name="X818C330582C88DE6"></a></p>

<h5>2.5-2 CapJitReplacedGlobalVariablesByCategoryAttributes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitReplacedGlobalVariablesByCategoryAttributes</code>( <var class="Arg">tree</var>, <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Applies the compiler hint <code class="code">category_attribute_names</code> (see <a href="chap1.html#X7E61259E7D6E8EEB"><span class="RefLink">1.6</span></a>) to <var class="Arg">tree</var>. Assumes that <var class="Arg">category</var> is the first argument of the function defined by <var class="Arg">tree</var>.</p>

<p><a id="X797464D18296B4BC" name="X797464D18296B4BC"></a></p>

<h5>2.5-3 CapJitReplacedSourceAndRangeAttributes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitReplacedSourceAndRangeAttributes</code>( <var class="Arg">tree</var>, <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Applies the compiler hint <code class="code">source_and_range_attributes_from_morphism_attribute</code> (see <a href="chap1.html#X7E61259E7D6E8EEB"><span class="RefLink">1.6</span></a>) to <var class="Arg">tree</var>.</p>

<p><a id="X7B2CAFD1864FA422" name="X7B2CAFD1864FA422"></a></p>

<h5>2.5-4 CapJitDeduplicatedExpressions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitDeduplicatedExpressions</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Deduplicates expressions occuring at least twice in the enhanced syntax tree <var class="Arg">tree</var>.</p>

<p><a id="X7A46699B7922FB1B" name="X7A46699B7922FB1B"></a></p>

<h5>2.5-5 CapJitDroppedHandledEdgeCases</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitDroppedHandledEdgeCases</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Idea: If the same edge case is handled multiple times in the tree by checking a condition and returning a value, all condition checks except the first can be dropped. Details: Keeps a record of conditions which immediately lead to a return, i.e., statements of the form <code class="code">if condition1 then return value; fi;</code>. If another statement of the form <code class="code">if condition2 then return value; fi;</code> is found later in the tree and if <code class="code">condition2 = true</code> implies <code class="code">condition1 = true</code>, the second statement is dropped.</p>

<p><a id="X7F43BA10869178AC" name="X7F43BA10869178AC"></a></p>

<h5>2.5-6 CapJitDroppedUnusedBindings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitDroppedUnusedBindings</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Drops bindings (and names) of variables in functions in <var class="Arg">tree</var> which are never referenced.</p>

<p><a id="X82763C7D7CAD3B16" name="X82763C7D7CAD3B16"></a></p>

<h5>2.5-7 CapJitHoistedExpressions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitHoistedExpressions</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Hoists expressions which are part of but indepedent of inner functions to outer functions.</p>

<p><a id="X7ADA6AEF8564A0EE" name="X7ADA6AEF8564A0EE"></a></p>

<h5>2.5-8 CapJitHoistedBindings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitHoistedBindings</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Hoists bindings which are part of but indepedent of inner functions to outer functions.</p>

<p><a id="X821BE2CE7C30674E" name="X821BE2CE7C30674E"></a></p>

<h5>2.5-9 CapJitInferredDataTypes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitInferredDataTypes</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Tries to infer the data types of expressions in <var class="Arg">tree</var> and attaches it as component <code class="code">data_type</code>. A data type is a record with component <code class="code">filter</code> (a GAP filter) and, depending on the filter, additional components:</p>


<ul>
<li><p><code class="code">IsFunction</code> with additional component <code class="code">signature</code>: The signature is a list with two entries. The first entry is a list of data types of the inputs, the second entry is the data type of the output.</p>

</li>
<li><p><code class="code">IsList</code> with additional component <code class="code">element_type</code>: The type of the elements of the list. Only homogeneous lists are supported.</p>

</li>
<li><p>filters implying <code class="code">IsCapCategory</code>, <code class="code">IsCapCategoryObject</code> or <code class="code">IsCapCategoryMorphism</code> with additional component <code class="code">category</code>: The category instance (to which the object or morphism belongs).</p>

</li>
</ul>
<p><a id="X7DF03AC082073C4C" name="X7DF03AC082073C4C"></a></p>

<h5>2.5-10 CapJitInlinedArguments</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitInlinedArguments</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Example: transforms <code class="code">(function(x) return x; end)(1)</code> into <code class="code">(function() local x; x := 1; return x; end)()</code>. Details: Searches for function calls of resolved functions. Assigns the argument values to local variables at the beginning of the function, and drops the arguments (i.e., makes the function a 0-ary function).</p>

<p><a id="X83E0BBEA80AD5CDE" name="X83E0BBEA80AD5CDE"></a></p>

<h5>2.5-11 CapJitInlinedBindings</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitInlinedBindings</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Example: transforms <code class="code">function() local x; x := 1; return x^2; end</code> into <code class="code">function() return 1^2; end()</code>. Details: Replaces references to local variables of a function by the value of the corresponding binding of the function. If the option <code class="code">inline_var_refs_only</code> is set to <code class="code">true</code>, this is only done if the value is a reference to a (local or global) variable. If the option <code class="code">inline_fully</code> is NOT set to <code class="code">true</code>, wrapped arguments are not inlined (see <code class="func">CapJitOutlinedWrappedArguments</code> (<a href="chap2.html#X79FD7D407C591072"><span class="RefLink">2.5-18</span></a>)). Also drops the inlined bindings.</p>

<p><a id="X82F8D6B5851674EB" name="X82F8D6B5851674EB"></a></p>

<h5>2.5-12 CapJitInlinedBindingsToVariableReferences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitInlinedBindingsToVariableReferences</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Short hand for <code class="code">CapJitInlinedBindings( </code><var class="Arg">tree</var><code class="code"> : inline_var_refs_only := true )</code>.</p>

<p><a id="X794E5E1F7D86BFAA" name="X794E5E1F7D86BFAA"></a></p>

<h5>2.5-13 CapJitInlinedBindingsFully</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitInlinedBindingsFully</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Short hand for <code class="code">CapJitInlinedBindings( </code><var class="Arg">tree</var><code class="code"> : inline_fully := true )</code>.</p>

<p><a id="X7933165D803DEDB2" name="X7933165D803DEDB2"></a></p>

<h5>2.5-14 CapJitInlinedFunctionCalls</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitInlinedFunctionCalls</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Example: transforms <code class="code">function() local x; x := (y -&gt; y + 2)(1); return x; end</code> into <code class="code">function() local x, y, r; y := 1; r := y + 2; x := r; return x; end</code>. Details: Searches for function calls of a resolved function in the right hand side of a variable assignment or a return statement. Inserts the body of the function right before the variable assignment / return statement to avoid the function call. Assumes that arguments of function calls are inlined (i.e., you should use <code class="func">CapJitInlinedArguments</code> (<a href="chap2.html#X7DF03AC082073C4C"><span class="RefLink">2.5-10</span></a>) first). Due to the nature of a <code class="code">return</code> statement breaking the execution and having no <code class="code">goto</code> keyword in GAP, only functions</p>


<ul>
<li><p>ending with a <code class="code">return</code> statement, or</p>

</li>
<li><p>ending with an if-(elif)-else-statement with <code class="code">return</code> statements at the end of all branches</p>

</li>
</ul>
<p>and not containing other <code class="code">return</code> statements can be inlined.</p>

<p><a id="X7C3064C27FBB1A0D" name="X7C3064C27FBB1A0D"></a></p>

<h5>2.5-15 CapJitInlinedSimpleFunctionCalls</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitInlinedSimpleFunctionCalls</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Replaces function calls of the form <code class="code">(function() return value; end)()</code> by <code class="code">value</code>. Assumes that arguments of function calls are inlined (i.e., you should use <code class="func">CapJitInlinedArguments</code> (<a href="chap2.html#X7DF03AC082073C4C"><span class="RefLink">2.5-10</span></a>) first).</p>

<p><a id="X837576207D282C04" name="X837576207D282C04"></a></p>

<h5>2.5-16 CapJitAppliedLogic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitAppliedLogic</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Applies all logic functions (see <code class="func">CapJitAddLogicFunction</code> (<a href="chap2.html#X804E3CAD82BE47BB"><span class="RefLink">2.1-1</span></a>)) and logic templates (see <code class="func">CapJitAppliedLogicTemplates</code> (<a href="chap2.html#X7AE756B8878FD449"><span class="RefLink">2.5-17</span></a>)) to <var class="Arg">tree</var>.</p>

<p><a id="X7AE756B8878FD449" name="X7AE756B8878FD449"></a></p>

<h5>2.5-17 CapJitAppliedLogicTemplates</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitAppliedLogicTemplates</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Applies all logic templates (see <code class="func">CapJitAddLogicTemplate</code> (<a href="chap2.html#X8592DC367A493530"><span class="RefLink">2.1-2</span></a>)) to <var class="Arg">tree</var>.</p>

<p><a id="X79FD7D407C591072" name="X79FD7D407C591072"></a></p>

<h5>2.5-18 CapJitOutlinedWrappedArguments</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitOutlinedWrappedArguments</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Outlines wrapped arguments to local variables. This includes:</p>


<ul>
<li><p>the attribute values in <code class="code">ObjectifyObjectForCAPWithAttributes</code></p>

</li>
<li><p>the attribute values (including the arguments <code class="code">source</code> and <code class="code">range</code>) in <code class="code">ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes</code></p>

</li>
<li><p>the entries of literal lists</p>

</li>
</ul>
<p><a id="X7FD883BA85F7EBE5" name="X7FD883BA85F7EBE5"></a></p>

<h5>2.5-19 CapJitResolvedGlobalVariables</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitResolvedGlobalVariables</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Resolves global variables (except those which are listed in <code class="code">CAP_JIT_NON_RESOLVABLE_GLOBAL_VARIABLE_NAMES</code>):</p>


<ul>
<li><p>Replaces a global variable referencing a plain function by the syntax tree of this function in case the function is annotated with the pragma <code class="code">CAP_JIT_RESOLVE_FUNCTION</code>.</p>

</li>
<li><p>Computes attributes of categories stored in global variables and places the results into global variables again.</p>

</li>
</ul>
<p><a id="X7D12C378812745DA" name="X7D12C378812745DA"></a></p>

<h5>2.5-20 CapJitResolvedOperations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitResolvedOperations</code>( <var class="Arg">tree</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Tries to resolve operations in <var class="Arg">tree</var>:</p>


<ul>
<li><p>Operations of CAP categories are resolved by taking one of the functions added to the category via an <code class="code">Add</code> function.</p>

</li>
<li><p>Operations announced to the compiler via <code class="code">InstallMethodForCompilerForCAP</code> or <code class="code">InstallOtherMethodForCompilerForCAP</code> (see the documentation of CAP) are resolved via the number of arguments.</p>

</li>
</ul>

<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
