# SPDX-License-Identifier: GPL-2.0-or-later
# CAP: Categories, Algorithms, Programming
#
# Implementations
#
# THIS FILE IS AUTOMATICALLY GENERATED, SEE LimitConvenience.gi
##
InstallMethod( UniversalMorphismIntoDirectProduct,
               [ IsList ],
               
  function( list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectProduct( CapCategory( list[1] ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategory, IsList ],
               
  function( cat, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectProduct( cat, List( list, Range ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryObject, IsList ],
               
  function( test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectProduct( CapCategory( test_object ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategory, IsCapCategoryObject, IsList ],
               
  function( cat, test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectProduct( cat, List( list, Range ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism ],
               
  function( mor1 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2, mor3 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2, mor3, mor4 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2, mor3, mor4, mor5 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5, mor6 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );
    
end );

InstallOtherMethod( UniversalMorphismIntoDirectProduct,
                    [ IsList, IsList ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectProduct( diagram, Source( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectProduct,
                    [ IsCapCategory, IsList, IsList ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectProduct( cat, diagram, Source( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectProductWithGivenDirectProduct,
                    [ IsList, IsList, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectProductWithGivenDirectProduct( diagram, Source( tau[1] ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectProductWithGivenDirectProduct,
                    [ IsCapCategory, IsList, IsList, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectProductWithGivenDirectProduct( cat, diagram, Source( tau[1] ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismIntoDirectProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectProduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectProduct with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoDirectProduct( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismIntoDirectProductWithGivenDirectProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectProductWithGivenDirectProduct with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectProductWithGivenDirectProduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoDirectProductWithGivenDirectProduct( category, wrapper );
    
end );

##
InstallMethod( UniversalMorphismFromCoproduct,
               [ IsList ],
               
  function( list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromCoproduct( CapCategory( list[1] ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategory, IsList ],
               
  function( cat, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromCoproduct( cat, List( list, Source ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryObject, IsList ],
               
  function( test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromCoproduct( CapCategory( test_object ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategory, IsCapCategoryObject, IsList ],
               
  function( cat, test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromCoproduct( cat, List( list, Source ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism ],
               
  function( mor1 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2, mor3 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2, mor3, mor4 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2, mor3, mor4, mor5 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5, mor6 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );
    
end );

InstallOtherMethod( UniversalMorphismFromCoproduct,
                    [ IsList, IsList ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoproduct( diagram, Range( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromCoproduct,
                    [ IsCapCategory, IsList, IsList ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoproduct( cat, diagram, Range( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromCoproductWithGivenCoproduct,
                    [ IsList, IsList, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoproductWithGivenCoproduct( diagram, Range( tau[1] ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismFromCoproductWithGivenCoproduct,
                    [ IsCapCategory, IsList, IsList, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoproductWithGivenCoproduct( cat, diagram, Range( tau[1] ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismFromCoproduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoproduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoproduct with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromCoproduct( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromCoproductWithGivenCoproduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoproductWithGivenCoproduct with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoproductWithGivenCoproduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromCoproductWithGivenCoproduct( category, wrapper );
    
end );

##
InstallOtherMethod( DirectProductFunctorial,
                    [ IsList ],
               
  function( L )
    
    return DirectProductFunctorial( List( L, Source ), L, List( L, Range ) );
    
end );

##
InstallOtherMethodForCompilerForCAP( DirectProductFunctorial,
                                     [ IsCapCategory, IsList ],
                    
  function( cat, L )
    
    return DirectProductFunctorial( cat, List( L, Source ), L, List( L, Range ) );
    
end );

##
InstallOtherMethod( DirectProductFunctorialWithGivenDirectProducts,
               [ IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( source, L, range )
    
    return DirectProductFunctorialWithGivenDirectProducts( source, List( L, Source ), L, List( L, Range ), range );
    
end );

##
InstallOtherMethodForCompilerForCAP( DirectProductFunctorialWithGivenDirectProducts,
                                     [ IsCapCategory, IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( cat, source, L, range )
    
    return DirectProductFunctorialWithGivenDirectProducts( cat, source, List( L, Source ), L, List( L, Range ), range );
    
end );

##
AddDerivationToCAP( DirectProductFunctorialWithGivenDirectProducts,
                    
  function( cat, P, objects, L, objectsp, Pp )
    
    return UniversalMorphismIntoDirectProductWithGivenDirectProduct( cat, objectsp, P, List( [ 1 .. Length( L ) ], i -> PreCompose( cat, ProjectionInFactorOfDirectProductWithGivenDirectProduct( cat, objects, i, P ), L[i] ) ), Pp );
    
end : Description := "DirectProductFunctorialWithGivenDirectProducts using the universality of the limit" );

##
InstallOtherMethod( CoproductFunctorial,
                    [ IsList ],
               
  function( L )
    
    return CoproductFunctorial( List( L, Source ), L, List( L, Range ) );
    
end );

##
InstallOtherMethodForCompilerForCAP( CoproductFunctorial,
                                     [ IsCapCategory, IsList ],
                    
  function( cat, L )
    
    return CoproductFunctorial( cat, List( L, Source ), L, List( L, Range ) );
    
end );

##
InstallOtherMethod( CoproductFunctorialWithGivenCoproducts,
               [ IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( source, L, range )
    
    return CoproductFunctorialWithGivenCoproducts( source, List( L, Source ), L, List( L, Range ), range );
    
end );

##
InstallOtherMethodForCompilerForCAP( CoproductFunctorialWithGivenCoproducts,
                                     [ IsCapCategory, IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( cat, source, L, range )
    
    return CoproductFunctorialWithGivenCoproducts( cat, source, List( L, Source ), L, List( L, Range ), range );
    
end );

##
AddDerivationToCAP( CoproductFunctorialWithGivenCoproducts,
                    
  function( cat, P, objects, L, objectsp, Pp )
    
    return UniversalMorphismFromCoproductWithGivenCoproduct( cat, objects, Pp, List( [ 1 .. Length( L ) ], i -> PreCompose( cat, L[i], InjectionOfCofactorOfCoproductWithGivenCoproduct( cat, objectsp, i, Pp ) ) ), P );
    
end : Description := "CoproductFunctorialWithGivenCoproducts using the universality of the colimit" );

##
InstallMethod( UniversalMorphismIntoDirectSum,
               [ IsList ],
               
  function( list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectSum( CapCategory( list[1] ), list );
    
end );

##
InstallOtherMethodForCompilerForCAP( UniversalMorphismIntoDirectSum,
               [ IsCapCategory, IsList ],
               
  function( cat, list )
    
    return UniversalMorphismIntoDirectSum( cat, List( list, Range ), Source( list[1] ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryObject, IsList ],
               
  function( test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectSum( CapCategory( test_object ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategory, IsCapCategoryObject, IsList ],
               
  function( cat, test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectSum( cat, List( list, Range ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism ],
               
  function( mor1 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2, mor3 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2, mor3, mor4 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2, mor3, mor4, mor5 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5, mor6 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );
    
end );

InstallOtherMethod( UniversalMorphismIntoDirectSum,
                    [ IsList, IsList ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectSum( diagram, Source( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectSum,
                    [ IsCapCategory, IsList, IsList ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectSum( cat, diagram, Source( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectSumWithGivenDirectSum,
                    [ IsList, IsList, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectSumWithGivenDirectSum( diagram, Source( tau[1] ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectSumWithGivenDirectSum,
                    [ IsCapCategory, IsList, IsList, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, diagram, Source( tau[1] ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismIntoDirectSum,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectSum with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectSum with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoDirectSum( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismIntoDirectSumWithGivenDirectSum,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectSumWithGivenDirectSum with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectSumWithGivenDirectSum with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoDirectSumWithGivenDirectSum( category, wrapper );
    
end );

##
InstallMethod( UniversalMorphismFromDirectSum,
               [ IsList ],
               
  function( list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromDirectSum( CapCategory( list[1] ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategory, IsList ],
               
  function( cat, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromDirectSum( cat, List( list, Source ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryObject, IsList ],
               
  function( test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromDirectSum( CapCategory( test_object ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategory, IsCapCategoryObject, IsList ],
               
  function( cat, test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromDirectSum( cat, List( list, Source ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism ],
               
  function( mor1 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2, mor3 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2, mor3, mor4 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2, mor3, mor4, mor5 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5, mor6 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );
    
end );

InstallOtherMethod( UniversalMorphismFromDirectSum,
                    [ IsList, IsList ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromDirectSum( diagram, Range( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromDirectSum,
                    [ IsCapCategory, IsList, IsList ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromDirectSum( cat, diagram, Range( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromDirectSumWithGivenDirectSum,
                    [ IsList, IsList, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromDirectSumWithGivenDirectSum( diagram, Range( tau[1] ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismFromDirectSumWithGivenDirectSum,
                    [ IsCapCategory, IsList, IsList, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, diagram, Range( tau[1] ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismFromDirectSum,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromDirectSum with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromDirectSum with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromDirectSum( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromDirectSumWithGivenDirectSum,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromDirectSumWithGivenDirectSum with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromDirectSumWithGivenDirectSum with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromDirectSumWithGivenDirectSum( category, wrapper );
    
end );

##
InstallOtherMethod( DirectSumFunctorial,
                    [ IsList ],
               
  function( L )
    
    return DirectSumFunctorial( List( L, Source ), L, List( L, Range ) );
    
end );

##
InstallOtherMethodForCompilerForCAP( DirectSumFunctorial,
                                     [ IsCapCategory, IsList ],
                    
  function( cat, L )
    
    return DirectSumFunctorial( cat, List( L, Source ), L, List( L, Range ) );
    
end );

##
InstallOtherMethod( DirectSumFunctorialWithGivenDirectSums,
               [ IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( source, L, range )
    
    return DirectSumFunctorialWithGivenDirectSums( source, List( L, Source ), L, List( L, Range ), range );
    
end );

##
InstallOtherMethodForCompilerForCAP( DirectSumFunctorialWithGivenDirectSums,
                                     [ IsCapCategory, IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( cat, source, L, range )
    
    return DirectSumFunctorialWithGivenDirectSums( cat, source, List( L, Source ), L, List( L, Range ), range );
    
end );

##
AddDerivationToCAP( DirectSumFunctorialWithGivenDirectSums,
                    
  function( cat, P, objects, L, objectsp, Pp )
    
    return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, objectsp, P, List( [ 1 .. Length( L ) ], i -> PreCompose( cat, ProjectionInFactorOfDirectSumWithGivenDirectSum( cat, objects, i, P ), L[i] ) ), Pp );
    
end : Description := "DirectSumFunctorialWithGivenDirectSums using the universality of the limit" );

##
AddDerivationToCAP( DirectSumFunctorialWithGivenDirectSums,
                    
  function( cat, P, objects, L, objectsp, Pp )
    
    return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, objects, Pp, List( [ 1 .. Length( L ) ], i -> PreCompose( cat, L[i], InjectionOfCofactorOfDirectSumWithGivenDirectSum( cat, objectsp, i, Pp ) ) ), P );
    
end : Description := "DirectSumFunctorialWithGivenDirectSums using the universality of the colimit" );

##
InstallMethod( AddUniversalMorphismIntoFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoFiberProduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoFiberProduct with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoFiberProduct( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismIntoFiberProductWithGivenFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoFiberProductWithGivenFiberProduct with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoFiberProductWithGivenFiberProduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoFiberProductWithGivenFiberProduct( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromPushout,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromPushout with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromPushout with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromPushout( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromPushoutWithGivenPushout,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromPushoutWithGivenPushout with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromPushoutWithGivenPushout with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromPushoutWithGivenPushout( category, wrapper );
    
end );

##
AddDerivationToCAP( FiberProductFunctorialWithGivenFiberProducts,
                    
  function( cat, P, morphisms, L, morphismsp, Pp )
    
    return UniversalMorphismIntoFiberProductWithGivenFiberProduct( cat, morphismsp, P, List( [ 1 .. Length( L ) ], i -> PreCompose( cat, ProjectionInFactorOfFiberProductWithGivenFiberProduct( cat, morphisms, i, P ), L[i] ) ), Pp );
    
end : Description := "FiberProductFunctorialWithGivenFiberProducts using the universality of the limit" );

##
AddDerivationToCAP( PushoutFunctorialWithGivenPushouts,
                    
  function( cat, P, morphisms, L, morphismsp, Pp )
    
    return UniversalMorphismFromPushoutWithGivenPushout( cat, morphisms, Pp, List( [ 1 .. Length( L ) ], i -> PreCompose( cat, L[i], InjectionOfCofactorOfPushoutWithGivenPushout( cat, morphismsp, i, Pp ) ) ), P );
    
end : Description := "PushoutFunctorialWithGivenPushouts using the universality of the colimit" );

InstallOtherMethod( UniversalMorphismIntoEqualizer,
                    [ IsList, IsCapCategoryMorphism ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoEqualizer( diagram, Source( tau ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoEqualizer,
                    [ IsCapCategory, IsList, IsCapCategoryMorphism ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoEqualizer( cat, diagram, Source( tau ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoEqualizerWithGivenEqualizer,
                    [ IsList, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoEqualizerWithGivenEqualizer( diagram, Source( tau ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismIntoEqualizerWithGivenEqualizer,
                    [ IsCapCategory, IsList, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoEqualizerWithGivenEqualizer( cat, diagram, Source( tau ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismIntoEqualizer,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoEqualizer with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoEqualizer with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoEqualizer( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismIntoEqualizerWithGivenEqualizer,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoEqualizerWithGivenEqualizer with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoEqualizerWithGivenEqualizer with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoEqualizerWithGivenEqualizer( category, wrapper );
    
end );

InstallOtherMethod( UniversalMorphismFromCoequalizer,
                    [ IsList, IsCapCategoryMorphism ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoequalizer( diagram, Range( tau ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromCoequalizer,
                    [ IsCapCategory, IsList, IsCapCategoryMorphism ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoequalizer( cat, diagram, Range( tau ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromCoequalizerWithGivenCoequalizer,
                    [ IsList, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoequalizerWithGivenCoequalizer( diagram, Range( tau ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismFromCoequalizerWithGivenCoequalizer,
                    [ IsCapCategory, IsList, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoequalizerWithGivenCoequalizer( cat, diagram, Range( tau ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismFromCoequalizer,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoequalizer with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoequalizer with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromCoequalizer( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromCoequalizerWithGivenCoequalizer,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoequalizerWithGivenCoequalizer with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoequalizerWithGivenCoequalizer with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromCoequalizerWithGivenCoequalizer( category, wrapper );
    
end );

##
AddDerivationToCAP( EqualizerFunctorialWithGivenEqualizers,
                    
  function( cat, P, morphisms, mu, morphismsp, Pp )
    
    return UniversalMorphismIntoEqualizerWithGivenEqualizer( cat, morphismsp, P, PreCompose( cat, EmbeddingOfEqualizerWithGivenEqualizer( cat, morphisms, P ), mu ), Pp );
    
end : Description := "EqualizerFunctorialWithGivenEqualizers using the universality of the limit" );

##
AddDerivationToCAP( CoequalizerFunctorialWithGivenCoequalizers,
                    
  function( cat, P, morphisms, mu, morphismsp, Pp )
    
    return UniversalMorphismFromCoequalizerWithGivenCoequalizer( cat, morphisms, Pp, PreCompose( cat, mu, ProjectionOntoCoequalizerWithGivenCoequalizer( cat, morphismsp, Pp ) ), P );
    
end : Description := "CoequalizerFunctorialWithGivenCoequalizers using the universality of the colimit" );

InstallOtherMethod( KernelLift,
                    [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return KernelLift( diagram, Source( tau ), tau );
        
end );

InstallOtherMethodForCompilerForCAP( KernelLift,
                    [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism ],
                    
    function( cat, diagram, tau )
        
        return KernelLift( cat, diagram, Source( tau ), tau );
        
end );

InstallOtherMethod( KernelLiftWithGivenKernelObject,
                    [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return KernelLiftWithGivenKernelObject( diagram, Source( tau ), tau, P );
        
end );

InstallOtherMethod( KernelLiftWithGivenKernelObject,
                    [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return KernelLiftWithGivenKernelObject( cat, diagram, Source( tau ), tau, P );
        
end );

##
InstallMethod( AddKernelLift,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddKernelLift with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddKernelLift with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddKernelLift( category, wrapper );
    
end );

##
InstallMethod( AddKernelLiftWithGivenKernelObject,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddKernelLiftWithGivenKernelObject with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddKernelLiftWithGivenKernelObject with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddKernelLiftWithGivenKernelObject( category, wrapper );
    
end );

InstallOtherMethod( CokernelColift,
                    [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return CokernelColift( diagram, Range( tau ), tau );
        
end );

InstallOtherMethodForCompilerForCAP( CokernelColift,
                    [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism ],
                    
    function( cat, diagram, tau )
        
        return CokernelColift( cat, diagram, Range( tau ), tau );
        
end );

InstallOtherMethod( CokernelColiftWithGivenCokernelObject,
                    [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return CokernelColiftWithGivenCokernelObject( diagram, Range( tau ), tau, P );
        
end );

InstallOtherMethod( CokernelColiftWithGivenCokernelObject,
                    [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return CokernelColiftWithGivenCokernelObject( cat, diagram, Range( tau ), tau, P );
        
end );

##
InstallMethod( AddCokernelColift,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddCokernelColift with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddCokernelColift with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddCokernelColift( category, wrapper );
    
end );

##
InstallMethod( AddCokernelColiftWithGivenCokernelObject,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddCokernelColiftWithGivenCokernelObject with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddCokernelColiftWithGivenCokernelObject with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddCokernelColiftWithGivenCokernelObject( category, wrapper );
    
end );

##
AddDerivationToCAP( KernelObjectFunctorialWithGivenKernelObjects,
                    
  function( cat, P, alpha, mu, alphap, Pp )
    
    return KernelLiftWithGivenKernelObject( cat, alphap, P, PreCompose( cat, KernelEmbeddingWithGivenKernelObject( cat, alpha, P ), mu ), Pp );
    
end : Description := "KernelObjectFunctorialWithGivenKernelObjects using the universality of the limit" );

##
AddDerivationToCAP( CokernelObjectFunctorialWithGivenCokernelObjects,
                    
  function( cat, P, alpha, mu, alphap, Pp )
    
    return CokernelColiftWithGivenCokernelObject( cat, alpha, Pp, PreCompose( cat, mu, CokernelProjectionWithGivenCokernelObject( cat, alphap, Pp ) ), P );
    
end : Description := "CokernelObjectFunctorialWithGivenCokernelObjects using the universality of the colimit" );

##
AddDerivationToCAP( TerminalObjectFunctorialWithGivenTerminalObjects,
                    
  function( cat, P, Pp )
    
    return UniversalMorphismIntoTerminalObjectWithGivenTerminalObject( cat, P, Pp );
    
end : Description := "TerminalObjectFunctorialWithGivenTerminalObjects using the universality of the limit" );

##
AddDerivationToCAP( TerminalObjectFunctorial,
                    
  function( cat )
    
    return IdentityMorphism( cat, TerminalObject( cat ) );
    
end : Description := "TerminalObjectFunctorial by taking the identity morphism of TerminalObject" );

##
AddDerivationToCAP( InitialObjectFunctorialWithGivenInitialObjects,
                    
  function( cat, P, Pp )
    
    return UniversalMorphismFromInitialObjectWithGivenInitialObject( cat, Pp, P );
    
end : Description := "InitialObjectFunctorialWithGivenInitialObjects using the universality of the colimit" );

##
AddDerivationToCAP( InitialObjectFunctorial,
                    
  function( cat )
    
    return IdentityMorphism( cat, InitialObject( cat ) );
    
end : Description := "InitialObjectFunctorial by taking the identity morphism of InitialObject" );

##
AddDerivationToCAP( ZeroObjectFunctorialWithGivenZeroObjects,
                    
  function( cat, P, Pp )
    
    return UniversalMorphismIntoZeroObjectWithGivenZeroObject( cat, P, Pp );
    
end : Description := "ZeroObjectFunctorialWithGivenZeroObjects using the universality of the limit" );

##
AddDerivationToCAP( ZeroObjectFunctorial,
                    
  function( cat )
    
    return IdentityMorphism( cat, ZeroObject( cat ) );
    
end : Description := "ZeroObjectFunctorial by taking the identity morphism of ZeroObject" );

##
AddDerivationToCAP( ZeroObjectFunctorialWithGivenZeroObjects,
                    
  function( cat, P, Pp )
    
    return UniversalMorphismFromZeroObjectWithGivenZeroObject( cat, Pp, P );
    
end : Description := "ZeroObjectFunctorialWithGivenZeroObjects using the universality of the colimit" );
